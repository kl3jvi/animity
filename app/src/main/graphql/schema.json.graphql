# This file was generated based on "schema.json". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"Activity union type"
union ActivityUnion = ListActivity | MessageActivity | TextActivity

"Likeable union type"
union LikeableUnion = ActivityReply | ListActivity | MessageActivity | TextActivity | Thread | ThreadComment

"Notification union type"
union NotificationUnion = ActivityLikeNotification | ActivityMentionNotification | ActivityMessageNotification | ActivityReplyLikeNotification | ActivityReplyNotification | ActivityReplySubscribedNotification | AiringNotification | FollowingNotification | MediaDataChangeNotification | MediaDeletionNotification | MediaMergeNotification | RelatedMediaAdditionNotification | ThreadCommentLikeNotification | ThreadCommentMentionNotification | ThreadCommentReplyNotification | ThreadCommentSubscribedNotification | ThreadLikeNotification

"Notification for when a activity is liked"
type ActivityLikeNotification {
    "The liked activity"
    activity: ActivityUnion
    "The id of the activity which was liked"
    activityId: Int!
    "The notification context text"
    context: String
    "The time the notification was created at"
    createdAt: Int
    "The id of the Notification"
    id: Int!
    "The type of notification"
    type: NotificationType
    "The user who liked the activity"
    user: User
    "The id of the user who liked to the activity"
    userId: Int!
}

"Notification for when authenticated user is @ mentioned in activity or reply"
type ActivityMentionNotification {
    "The liked activity"
    activity: ActivityUnion
    "The id of the activity where mentioned"
    activityId: Int!
    "The notification context text"
    context: String
    "The time the notification was created at"
    createdAt: Int
    "The id of the Notification"
    id: Int!
    "The type of notification"
    type: NotificationType
    "The user who mentioned the authenticated user"
    user: User
    "The id of the user who mentioned the authenticated user"
    userId: Int!
}

"Notification for when a user is send an activity message"
type ActivityMessageNotification {
    "The id of the activity message"
    activityId: Int!
    "The notification context text"
    context: String
    "The time the notification was created at"
    createdAt: Int
    "The id of the Notification"
    id: Int!
    "The message activity"
    message: MessageActivity
    "The type of notification"
    type: NotificationType
    "The user who sent the message"
    user: User
    "The if of the user who send the message"
    userId: Int!
}

"Replay to an activity item"
type ActivityReply {
    "The id of the parent activity"
    activityId: Int
    "The time the reply was created at"
    createdAt: Int!
    "The id of the reply"
    id: Int!
    "If the currently authenticated user liked the reply"
    isLiked: Boolean
    "The amount of likes the reply has"
    likeCount: Int!
    "The users who liked the reply"
    likes: [User]
    "The reply text"
    text(
        "Return the string in pre-parsed html instead of markdown"
        asHtml: Boolean
    ): String
    "The user who created reply"
    user: User
    "The id of the replies creator"
    userId: Int
}

"Notification for when a activity reply is liked"
type ActivityReplyLikeNotification {
    "The liked activity"
    activity: ActivityUnion
    "The id of the activity where the reply which was liked"
    activityId: Int!
    "The notification context text"
    context: String
    "The time the notification was created at"
    createdAt: Int
    "The id of the Notification"
    id: Int!
    "The type of notification"
    type: NotificationType
    "The user who liked the activity reply"
    user: User
    "The id of the user who liked to the activity reply"
    userId: Int!
}

"Notification for when a user replies to the authenticated users activity"
type ActivityReplyNotification {
    "The liked activity"
    activity: ActivityUnion
    "The id of the activity which was replied too"
    activityId: Int!
    "The notification context text"
    context: String
    "The time the notification was created at"
    createdAt: Int
    "The id of the Notification"
    id: Int!
    "The type of notification"
    type: NotificationType
    "The user who replied to the activity"
    user: User
    "The id of the user who replied to the activity"
    userId: Int!
}

"Notification for when a user replies to activity the authenticated user has replied to"
type ActivityReplySubscribedNotification {
    "The liked activity"
    activity: ActivityUnion
    "The id of the activity which was replied too"
    activityId: Int!
    "The notification context text"
    context: String
    "The time the notification was created at"
    createdAt: Int
    "The id of the Notification"
    id: Int!
    "The type of notification"
    type: NotificationType
    "The user who replied to the activity"
    user: User
    "The id of the user who replied to the activity"
    userId: Int!
}

"Notification for when an episode of anime airs"
type AiringNotification {
    "The id of the aired anime"
    animeId: Int!
    "The notification context text"
    contexts: [String]
    "The time the notification was created at"
    createdAt: Int
    "The episode number that just aired"
    episode: Int!
    "The id of the Notification"
    id: Int!
    "The associated media of the airing schedule"
    media: Media
    "The type of notification"
    type: NotificationType
}

"Score & Watcher stats for airing anime by episode and mid-week"
type AiringProgression {
    "The episode the stats were recorded at. .5 is the mid point between 2 episodes airing dates."
    episode: Float
    "The average score for the media"
    score: Float
    "The amount of users watching the anime"
    watching: Int
}

"Media Airing Schedule. NOTE: We only aim to guarantee that FUTURE airing data is present and accurate."
type AiringSchedule {
    "The time the episode airs at"
    airingAt: Int!
    "The airing episode number"
    episode: Int!
    "The id of the airing schedule item"
    id: Int!
    "The associate media of the airing episode"
    media: Media
    "The associate media id of the airing episode"
    mediaId: Int!
    "Seconds until episode starts airing"
    timeUntilAiring: Int!
}

type AiringScheduleConnection {
    edges: [AiringScheduleEdge]
    nodes: [AiringSchedule]
    "The pagination information"
    pageInfo: PageInfo
}

"AiringSchedule connection edge"
type AiringScheduleEdge {
    "The id of the connection"
    id: Int
    node: AiringSchedule
}

type AniChartUser {
    highlights: Json
    settings: Json
    user: User
}

"A character that features in an anime or manga"
type Character {
    "The character's age. Note this is a string, not an int, it may contain further text and additional ages."
    age: String
    "The characters blood type"
    bloodType: String
    "The character's birth date"
    dateOfBirth: FuzzyDate
    "A general description of the character"
    description(
        "Return the string in pre-parsed html instead of markdown"
        asHtml: Boolean
    ): String
    "The amount of user's who have favourited the character"
    favourites: Int
    "The character's gender. Usually Male, Female, or Non-binary but can be any string."
    gender: String
    "The id of the character"
    id: Int!
    "Character images"
    image: CharacterImage
    "If the character is marked as favourite by the currently authenticated user"
    isFavourite: Boolean!
    "If the character is blocked from being added to favourites"
    isFavouriteBlocked: Boolean!
    "Media that includes the character"
    media(
        onList: Boolean,
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        sort: [MediaSort],
        type: MediaType
    ): MediaConnection
    "Notes for site moderators"
    modNotes: String
    "The names of the character"
    name: CharacterName
    "The url for the character page on the AniList website"
    siteUrl: String
    updatedAt: Int @deprecated(reason: "No data available")
}

type CharacterConnection {
    edges: [CharacterEdge]
    nodes: [Character]
    "The pagination information"
    pageInfo: PageInfo
}

"Character connection edge"
type CharacterEdge {
    "The order the character should be displayed from the users favourites"
    favouriteOrder: Int
    "The id of the connection"
    id: Int
    "The media the character is in"
    media: [Media]
    "Media specific character name"
    name: String
    node: Character
    "The characters role in the media"
    role: CharacterRole
    "The voice actors of the character with role date"
    voiceActorRoles(language: StaffLanguage, sort: [StaffSort]): [StaffRoleType]
    "The voice actors of the character"
    voiceActors(language: StaffLanguage, sort: [StaffSort]): [Staff]
}

type CharacterImage {
    "The character's image of media at its largest size"
    large: String
    "The character's image of media at medium size"
    medium: String
}

"The names of the character"
type CharacterName {
    "Other names the character might be referred to as"
    alternative: [String]
    "Other names the character might be referred to as but are spoilers"
    alternativeSpoiler: [String]
    "The character's given name"
    first: String
    "The character's first and last name"
    full: String
    "The character's surname"
    last: String
    "The character's middle name"
    middle: String
    "The character's full name in their native language"
    native: String
    "The currently authenticated users preferred name language. Default romaji for non-authenticated"
    userPreferred: String
}

"A submission for a character that features in an anime or manga"
type CharacterSubmission {
    "Data Mod assigned to handle the submission"
    assignee: User
    "Character that the submission is referencing"
    character: Character
    createdAt: Int
    "The id of the submission"
    id: Int!
    "Whether the submission is locked"
    locked: Boolean
    "Inner details of submission status"
    notes: String
    source: String
    "Status of the submission"
    status: SubmissionStatus
    "The character submission changes"
    submission: Character
    "Submitter for the submission"
    submitter: User
}

type CharacterSubmissionConnection {
    edges: [CharacterSubmissionEdge]
    nodes: [CharacterSubmission]
    "The pagination information"
    pageInfo: PageInfo
}

"CharacterSubmission connection edge"
type CharacterSubmissionEdge {
    node: CharacterSubmission
    "The characters role in the media"
    role: CharacterRole
    "The submitted voice actors of the character"
    submittedVoiceActors: [StaffSubmission]
    "The voice actors of the character"
    voiceActors: [Staff]
}

"Deleted data type"
type Deleted {
    "If an item has been successfully deleted"
    deleted: Boolean
}

"User's favourite anime, manga, characters, staff & studios"
type Favourites {
    "Favourite anime"
    anime(
        "The page number"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int
    ): MediaConnection
    "Favourite characters"
    characters(
        "The page number"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int
    ): CharacterConnection
    "Favourite manga"
    manga(
        "The page number"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int
    ): MediaConnection
    "Favourite staff"
    staff(
        "The page number"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int
    ): StaffConnection
    "Favourite studios"
    studios(
        "The page number"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int
    ): StudioConnection
}

"Notification for when the authenticated user is followed by another user"
type FollowingNotification {
    "The notification context text"
    context: String
    "The time the notification was created at"
    createdAt: Int
    "The id of the Notification"
    id: Int!
    "The type of notification"
    type: NotificationType
    "The liked activity"
    user: User
    "The id of the user who followed the authenticated user"
    userId: Int!
}

"User's format statistics"
type FormatStats {
    amount: Int
    format: MediaFormat
}

"Date object that allows for incomplete date values (fuzzy)"
type FuzzyDate {
    "Numeric Day (24)"
    day: Int
    "Numeric Month (3)"
    month: Int
    "Numeric Year (2017)"
    year: Int
}

"User's genre statistics"
type GenreStats {
    amount: Int
    genre: String
    meanScore: Int
    "The amount of time in minutes the genre has been watched by the user"
    timeWatched: Int
}

"Page of data (Used for internal use only)"
type InternalPage {
    activities(
        "Filter by the time the activity was created"
        createdAt: Int,
        "Filter by the time the activity was created"
        createdAt_greater: Int,
        "Filter by the time the activity was created"
        createdAt_lesser: Int,
        "Filter activity to only activity with replies"
        hasReplies: Boolean,
        "Filter activity to only activity with replies or is of type text"
        hasRepliesOrTypeText: Boolean,
        "Filter by the activity id"
        id: Int,
        "Filter by the activity id"
        id_in: [Int],
        "Filter by the activity id"
        id_not: Int,
        "Filter by the activity id"
        id_not_in: [Int],
        "Filter activity to users who are being followed by the authenticated user"
        isFollowing: Boolean,
        "Filter by the associated media id of the activity"
        mediaId: Int,
        "Filter by the associated media id of the activity"
        mediaId_in: [Int],
        "Filter by the associated media id of the activity"
        mediaId_not: Int,
        "Filter by the associated media id of the activity"
        mediaId_not_in: [Int],
        "Filter by the id of the user who sent a message"
        messengerId: Int,
        "Filter by the id of the user who sent a message"
        messengerId_in: [Int],
        "Filter by the id of the user who sent a message"
        messengerId_not: Int,
        "Filter by the id of the user who sent a message"
        messengerId_not_in: [Int],
        "The order the results will be returned in"
        sort: [ActivitySort],
        "Filter by the type of activity"
        type: ActivityType,
        "Filter by the type of activity"
        type_in: [ActivityType],
        "Filter by the type of activity"
        type_not: ActivityType,
        "Filter by the type of activity"
        type_not_in: [ActivityType],
        "Filter by the owner user id"
        userId: Int,
        "Filter by the owner user id"
        userId_in: [Int],
        "Filter by the owner user id"
        userId_not: Int,
        "Filter by the owner user id"
        userId_not_in: [Int]
    ): [ActivityUnion]
    activityReplies(
        "Filter by the parent id"
        activityId: Int,
        "Filter by the reply id"
        id: Int
    ): [ActivityReply]
    airingSchedules(
        "Filter by the time of airing"
        airingAt: Int,
        "Filter by the time of airing"
        airingAt_greater: Int,
        "Filter by the time of airing"
        airingAt_lesser: Int,
        "Filter by the airing episode number"
        episode: Int,
        "Filter by the airing episode number"
        episode_greater: Int,
        "Filter by the airing episode number"
        episode_in: [Int],
        "Filter by the airing episode number"
        episode_lesser: Int,
        "Filter by the airing episode number"
        episode_not: Int,
        "Filter by the airing episode number"
        episode_not_in: [Int],
        "Filter by the id of the airing schedule item"
        id: Int,
        "Filter by the id of the airing schedule item"
        id_in: [Int],
        "Filter by the id of the airing schedule item"
        id_not: Int,
        "Filter by the id of the airing schedule item"
        id_not_in: [Int],
        "Filter by the id of associated media"
        mediaId: Int,
        "Filter by the id of associated media"
        mediaId_in: [Int],
        "Filter by the id of associated media"
        mediaId_not: Int,
        "Filter by the id of associated media"
        mediaId_not_in: [Int],
        "Filter to episodes that haven't yet aired"
        notYetAired: Boolean,
        "The order the results will be returned in"
        sort: [AiringSort]
    ): [AiringSchedule]
    characterSubmissions(
        assigneeId: Int,
        characterId: Int,
        "The order the results will be returned in"
        sort: [SubmissionSort],
        "Filter by the status of the submission"
        status: SubmissionStatus,
        "Filter by the submitter of the submission"
        userId: Int
    ): [CharacterSubmission]
    characters(
        "Filter by character id"
        id: Int,
        "Filter by character id"
        id_in: [Int],
        "Filter by character id"
        id_not: Int,
        "Filter by character id"
        id_not_in: [Int],
        "Filter by character by if its their birthday today"
        isBirthday: Boolean,
        "Filter by search query"
        search: String,
        "The order the results will be returned in"
        sort: [CharacterSort]
    ): [Character]
    followers(
        "The order the results will be returned in"
        sort: [UserSort],
        "User id of the follower/followed"
        userId: Int!
    ): [User]
    following(
        "The order the results will be returned in"
        sort: [UserSort],
        "User id of the follower/followed"
        userId: Int!
    ): [User]
    likes(
        "The id of the likeable type"
        likeableId: Int,
        "The type of model the id applies to"
        type: LikeableType
    ): [User]
    media(
        "Filter by the media's average score"
        averageScore: Int,
        "Filter by the media's average score"
        averageScore_greater: Int,
        "Filter by the media's average score"
        averageScore_lesser: Int,
        "Filter by the media's average score"
        averageScore_not: Int,
        "Filter by the media's chapter count"
        chapters: Int,
        "Filter by the media's chapter count"
        chapters_greater: Int,
        "Filter by the media's chapter count"
        chapters_lesser: Int,
        "Filter by the media's country of origin"
        countryOfOrigin: CountryCode,
        "Filter by the media's episode length"
        duration: Int,
        "Filter by the media's episode length"
        duration_greater: Int,
        "Filter by the media's episode length"
        duration_lesser: Int,
        "Filter by the end date of the media"
        endDate: FuzzyDateInt,
        "Filter by the end date of the media"
        endDate_greater: FuzzyDateInt,
        "Filter by the end date of the media"
        endDate_lesser: FuzzyDateInt,
        "Filter by the end date of the media"
        endDate_like: String,
        "Filter by amount of episodes the media has"
        episodes: Int,
        "Filter by amount of episodes the media has"
        episodes_greater: Int,
        "Filter by amount of episodes the media has"
        episodes_lesser: Int,
        "Filter by the media's format"
        format: MediaFormat,
        "Filter by the media's format"
        format_in: [MediaFormat],
        "Filter by the media's format"
        format_not: MediaFormat,
        "Filter by the media's format"
        format_not_in: [MediaFormat],
        "Filter by the media's genres"
        genre: String,
        "Filter by the media's genres"
        genre_in: [String],
        "Filter by the media's genres"
        genre_not_in: [String],
        "Filter by the media id"
        id: Int,
        "Filter by the media's MyAnimeList id"
        idMal: Int,
        "Filter by the media's MyAnimeList id"
        idMal_in: [Int],
        "Filter by the media's MyAnimeList id"
        idMal_not: Int,
        "Filter by the media's MyAnimeList id"
        idMal_not_in: [Int],
        "Filter by the media id"
        id_in: [Int],
        "Filter by the media id"
        id_not: Int,
        "Filter by the media id"
        id_not_in: [Int],
        "Filter by if the media's intended for 18+ adult audiences"
        isAdult: Boolean,
        "If the media is officially licensed or a self-published doujin release"
        isLicensed: Boolean,
        "Filter media by sites with a online streaming or reading license"
        licensedBy: String,
        "Filter media by sites with a online streaming or reading license"
        licensedBy_in: [String],
        "Only apply the tags filter argument to tags above this rank. Default: 18"
        minimumTagRank: Int,
        "Filter by the media on the authenticated user's lists"
        onList: Boolean,
        "Filter by the number of users with this media on their list"
        popularity: Int,
        "Filter by the number of users with this media on their list"
        popularity_greater: Int,
        "Filter by the number of users with this media on their list"
        popularity_lesser: Int,
        "Filter by the number of users with this media on their list"
        popularity_not: Int,
        "Filter by search query"
        search: String,
        "Filter by the season the media was released in"
        season: MediaSeason,
        "The year of the season (Winter 2017 would also include December 2016 releases). Requires season argument"
        seasonYear: Int,
        "The order the results will be returned in"
        sort: [MediaSort],
        "Filter by the source type of the media"
        source: MediaSource,
        "Filter by the source type of the media"
        source_in: [MediaSource],
        "Filter by the start date of the media"
        startDate: FuzzyDateInt,
        "Filter by the start date of the media"
        startDate_greater: FuzzyDateInt,
        "Filter by the start date of the media"
        startDate_lesser: FuzzyDateInt,
        "Filter by the start date of the media"
        startDate_like: String,
        "Filter by the media's current release status"
        status: MediaStatus,
        "Filter by the media's current release status"
        status_in: [MediaStatus],
        "Filter by the media's current release status"
        status_not: MediaStatus,
        "Filter by the media's current release status"
        status_not_in: [MediaStatus],
        "Filter by the media's tags"
        tag: String,
        "Filter by the media's tags with in a tag category"
        tagCategory: String,
        "Filter by the media's tags with in a tag category"
        tagCategory_in: [String],
        "Filter by the media's tags with in a tag category"
        tagCategory_not_in: [String],
        "Filter by the media's tags"
        tag_in: [String],
        "Filter by the media's tags"
        tag_not_in: [String],
        "Filter by the media's type"
        type: MediaType,
        "Filter by the media's volume count"
        volumes: Int,
        "Filter by the media's volume count"
        volumes_greater: Int,
        "Filter by the media's volume count"
        volumes_lesser: Int
    ): [Media]
    mediaList(
        "Limit to only entries also on the auth user's list. Requires user id or name arguments."
        compareWithAuthList: Boolean,
        "Filter by the date the user completed the media"
        completedAt: FuzzyDateInt,
        "Filter by the date the user completed the media"
        completedAt_greater: FuzzyDateInt,
        "Filter by the date the user completed the media"
        completedAt_lesser: FuzzyDateInt,
        "Filter by the date the user completed the media"
        completedAt_like: String,
        "Filter by a list entry's id"
        id: Int,
        "Filter list entries to users who are being followed by the authenticated user"
        isFollowing: Boolean,
        "Filter by the media id of the list entry"
        mediaId: Int,
        "Filter by the media id of the list entry"
        mediaId_in: [Int],
        "Filter by the media id of the list entry"
        mediaId_not_in: [Int],
        "Filter by note words and #tags"
        notes: String,
        "Filter by note words and #tags"
        notes_like: String,
        "The order the results will be returned in"
        sort: [MediaListSort],
        "Filter by the date the user started the media"
        startedAt: FuzzyDateInt,
        "Filter by the date the user started the media"
        startedAt_greater: FuzzyDateInt,
        "Filter by the date the user started the media"
        startedAt_lesser: FuzzyDateInt,
        "Filter by the date the user started the media"
        startedAt_like: String,
        "Filter by the watching/reading status"
        status: MediaListStatus,
        "Filter by the watching/reading status"
        status_in: [MediaListStatus],
        "Filter by the watching/reading status"
        status_not: MediaListStatus,
        "Filter by the watching/reading status"
        status_not_in: [MediaListStatus],
        "Filter by the list entries media type"
        type: MediaType,
        "Filter by a user's id"
        userId: Int,
        "Filter by a user's id"
        userId_in: [Int],
        "Filter by a user's name"
        userName: String
    ): [MediaList]
    mediaSubmissions(
        assigneeId: Int,
        mediaId: Int,
        "The order the results will be returned in"
        sort: [SubmissionSort],
        status: SubmissionStatus,
        submissionId: Int,
        "Filter by the media's type"
        type: MediaType,
        userId: Int
    ): [MediaSubmission]
    mediaTrends(
        "Filter by score"
        averageScore: Int,
        "Filter by score"
        averageScore_greater: Int,
        "Filter by score"
        averageScore_lesser: Int,
        "Filter by score"
        averageScore_not: Int,
        "Filter by date"
        date: Int,
        "Filter by date"
        date_greater: Int,
        "Filter by date"
        date_lesser: Int,
        "Filter by episode number"
        episode: Int,
        "Filter by episode number"
        episode_greater: Int,
        "Filter by episode number"
        episode_lesser: Int,
        "Filter by episode number"
        episode_not: Int,
        "Filter by the media id"
        mediaId: Int,
        "Filter by the media id"
        mediaId_in: [Int],
        "Filter by the media id"
        mediaId_not: Int,
        "Filter by the media id"
        mediaId_not_in: [Int],
        "Filter by popularity"
        popularity: Int,
        "Filter by popularity"
        popularity_greater: Int,
        "Filter by popularity"
        popularity_lesser: Int,
        "Filter by popularity"
        popularity_not: Int,
        "Filter to stats recorded while the media was releasing"
        releasing: Boolean,
        "The order the results will be returned in"
        sort: [MediaTrendSort],
        "Filter by trending amount"
        trending: Int,
        "Filter by trending amount"
        trending_greater: Int,
        "Filter by trending amount"
        trending_lesser: Int,
        "Filter by trending amount"
        trending_not: Int
    ): [MediaTrend]
    modActions(modId: Int, userId: Int): [ModAction]
    notifications(
        "Reset the unread notification count to 0 on load"
        resetNotificationCount: Boolean,
        "Filter by the type of notifications"
        type: NotificationType,
        "Filter by the type of notifications"
        type_in: [NotificationType]
    ): [NotificationUnion]
    "The pagination information"
    pageInfo: PageInfo
    recommendations(
        "Filter by recommendation id"
        id: Int,
        "Filter by media id"
        mediaId: Int,
        "Filter by media recommendation id"
        mediaRecommendationId: Int,
        "Filter by the media on the authenticated user's lists"
        onList: Boolean,
        "Filter by total rating of the recommendation"
        rating: Int,
        "Filter by total rating of the recommendation"
        rating_greater: Int,
        "Filter by total rating of the recommendation"
        rating_lesser: Int,
        "The order the results will be returned in"
        sort: [RecommendationSort],
        "Filter by user who created the recommendation"
        userId: Int
    ): [Recommendation]
    reports(reportedId: Int, reporterId: Int): [Report]
    reviews(
        "Filter by Review id"
        id: Int,
        "Filter by media id"
        mediaId: Int,
        "Filter by media type"
        mediaType: MediaType,
        "The order the results will be returned in"
        sort: [ReviewSort],
        "Filter by user id"
        userId: Int
    ): [Review]
    revisionHistory(
        "Filter by the character id"
        characterId: Int,
        "Filter by the media id"
        mediaId: Int,
        "Filter by the staff id"
        staffId: Int,
        "Filter by the studio id"
        studioId: Int,
        "Filter by the user id"
        userId: Int
    ): [RevisionHistory]
    staff(
        "Filter by the staff id"
        id: Int,
        "Filter by the staff id"
        id_in: [Int],
        "Filter by the staff id"
        id_not: Int,
        "Filter by the staff id"
        id_not_in: [Int],
        "Filter by staff by if its their birthday today"
        isBirthday: Boolean,
        "Filter by search query"
        search: String,
        "The order the results will be returned in"
        sort: [StaffSort]
    ): [Staff]
    staffSubmissions(
        assigneeId: Int,
        "The order the results will be returned in"
        sort: [SubmissionSort],
        staffId: Int,
        "Filter by the status of the submission"
        status: SubmissionStatus,
        "Filter by the submitter of the submission"
        userId: Int
    ): [StaffSubmission]
    studios(
        "Filter by the studio id"
        id: Int,
        "Filter by the studio id"
        id_in: [Int],
        "Filter by the studio id"
        id_not: Int,
        "Filter by the studio id"
        id_not_in: [Int],
        "Filter by search query"
        search: String,
        "The order the results will be returned in"
        sort: [StudioSort]
    ): [Studio]
    threadComments(
        "Filter by the comment id"
        id: Int,
        "The order the results will be returned in"
        sort: [ThreadCommentSort],
        "Filter by the thread id"
        threadId: Int,
        "Filter by the user id of the comment's creator"
        userId: Int
    ): [ThreadComment]
    threads(
        "Filter by thread category id"
        categoryId: Int,
        "Filter by the thread id"
        id: Int,
        "Filter by the thread id"
        id_in: [Int],
        "Filter by thread media id category"
        mediaCategoryId: Int,
        "Filter by the user id of the last user to comment on the thread"
        replyUserId: Int,
        "Filter by search query"
        search: String,
        "The order the results will be returned in"
        sort: [ThreadSort],
        "Filter by if the currently authenticated user's subscribed threads"
        subscribed: Boolean,
        "Filter by the user id of the thread's creator"
        userId: Int
    ): [Thread]
    userBlockSearch(
        "Filter by search query"
        search: String
    ): [User]
    users(
        "Filter by the user id"
        id: Int,
        "Filter to moderators only if true"
        isModerator: Boolean,
        "Filter by the name of the user"
        name: String,
        "Filter by search query"
        search: String,
        "The order the results will be returned in"
        sort: [UserSort]
    ): [User]
}

"User list activity (anime & manga updates)"
type ListActivity {
    "The time the activity was created at"
    createdAt: Int!
    "The id of the activity"
    id: Int!
    "If the currently authenticated user liked the activity"
    isLiked: Boolean
    "If the activity is locked and can receive replies"
    isLocked: Boolean
    "If the currently authenticated user is subscribed to the activity"
    isSubscribed: Boolean
    "The amount of likes the activity has"
    likeCount: Int!
    "The users who liked the activity"
    likes: [User]
    "The associated media to the activity update"
    media: Media
    "The list progress made"
    progress: String
    "The written replies to the activity"
    replies: [ActivityReply]
    "The number of activity replies"
    replyCount: Int!
    "The url for the activity page on the AniList website"
    siteUrl: String
    "The list item's textual status"
    status: String
    "The type of activity"
    type: ActivityType
    "The owner of the activity"
    user: User
    "The user id of the activity's creator"
    userId: Int
}

"User's list score statistics"
type ListScoreStats {
    meanScore: Int
    standardDeviation: Int
}

"Anime or Manga"
type Media {
    "The media's entire airing schedule"
    airingSchedule(
        "Filter to episodes that have not yet aired"
        notYetAired: Boolean,
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int
    ): AiringScheduleConnection
    "If the media should have forum thread automatically created for it on airing episode release"
    autoCreateForumThread: Boolean
    "A weighted average score of all the user's scores of the media"
    averageScore: Int
    "The banner image of the media"
    bannerImage: String
    "The amount of chapters the manga has when complete"
    chapters: Int
    "The characters in the media"
    characters(
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        role: CharacterRole,
        sort: [CharacterSort]
    ): CharacterConnection
    "Where the media was created. (ISO 3166-1 alpha-2)"
    countryOfOrigin: CountryCode
    "The cover images of the media"
    coverImage: MediaCoverImage
    "Short description of the media's story and characters"
    description(
        "Return the string in pre-parsed html instead of markdown"
        asHtml: Boolean
    ): String
    "The general length of each anime episode in minutes"
    duration: Int
    "The last official release date of the media"
    endDate: FuzzyDate
    "The amount of episodes the anime has when complete"
    episodes: Int
    "External links to another site related to the media"
    externalLinks: [MediaExternalLink]
    "The amount of user's who have favourited the media"
    favourites: Int
    "The format the media was released in"
    format: MediaFormat
    "The genres of the media"
    genres: [String]
    "Official Twitter hashtags for the media"
    hashtag: String
    "The id of the media"
    id: Int!
    "The mal id of the media"
    idMal: Int
    "If the media is intended only for 18+ adult audiences"
    isAdult: Boolean
    "If the media is marked as favourite by the current authenticated user"
    isFavourite: Boolean!
    "If the media is blocked from being added to favourites"
    isFavouriteBlocked: Boolean!
    "If the media is officially licensed or a self-published doujin release"
    isLicensed: Boolean
    "Locked media may not be added to lists our favorited. This may be due to the entry pending for deletion or other reasons."
    isLocked: Boolean
    "If the media is blocked from being recommended to/from"
    isRecommendationBlocked: Boolean
    "Mean score of all the user's scores of the media"
    meanScore: Int
    "The authenticated user's media list entry for the media"
    mediaListEntry: MediaList
    "Notes for site moderators"
    modNotes: String
    "The media's next episode airing schedule"
    nextAiringEpisode: AiringSchedule
    "The number of users with the media on their list"
    popularity: Int
    "The ranking of the media in a particular time span and format compared to other media"
    rankings: [MediaRank]
    "User recommendations for similar media"
    recommendations(
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        sort: [RecommendationSort]
    ): RecommendationConnection
    "Other media in the same or connecting franchise"
    relations: MediaConnection
    "User reviews of the media"
    reviews(
        limit: Int,
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        sort: [ReviewSort]
    ): ReviewConnection
    "The season the media was initially released in"
    season: MediaSeason
    "The year & season the media was initially released in"
    seasonInt: Int
    "The season year the media was initially released in"
    seasonYear: Int
    "The url for the media page on the AniList website"
    siteUrl: String
    "Source type the media was adapted from."
    source(
        "Provide 2 or 3 to use new version 2 or 3 of sources enum"
        version: Int
    ): MediaSource
    "The staff who produced the media"
    staff(
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        sort: [StaffSort]
    ): StaffConnection
    "The first official release date of the media"
    startDate: FuzzyDate
    stats: MediaStats
    "The current releasing status of the media"
    status(
        "Provide 2 to use new version 2 of sources enum"
        version: Int
    ): MediaStatus
    "Data and links to legal streaming episodes on external sites"
    streamingEpisodes: [MediaStreamingEpisode]
    "The companies who produced the media"
    studios(isMain: Boolean, sort: [StudioSort]): StudioConnection
    "Alternative titles of the media"
    synonyms: [String]
    "List of tags that describes elements and themes of the media"
    tags: [MediaTag]
    "The official titles of the media in various languages"
    title: MediaTitle
    "Media trailer or advertisement"
    trailer: MediaTrailer
    "The amount of related activity in the past hour"
    trending: Int
    "The media's daily trend stats"
    trends(
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        "Filter to stats recorded while the media was releasing"
        releasing: Boolean,
        sort: [MediaTrendSort]
    ): MediaTrendConnection
    "The type of the media; anime or manga"
    type: MediaType
    "When the media's data was last updated"
    updatedAt: Int
    "The amount of volumes the manga has when complete"
    volumes: Int
}

"Internal - Media characters separated"
type MediaCharacter {
    "The characters in the media voiced by the parent actor"
    character: Character
    "Media specific character name"
    characterName: String
    dubGroup: String
    "The id of the connection"
    id: Int
    "The characters role in the media"
    role: CharacterRole
    roleNotes: String
    "The voice actor of the character"
    voiceActor: Staff
}

type MediaConnection {
    edges: [MediaEdge]
    nodes: [Media]
    "The pagination information"
    pageInfo: PageInfo
}

type MediaCoverImage {
    "Average #hex color of cover image"
    color: String
    "The cover image url of the media at its largest size. If this size isn't available, large will be provided instead."
    extraLarge: String
    "The cover image url of the media at a large size"
    large: String
    "The cover image url of the media at medium size"
    medium: String
}

"Notification for when a media entry's data was changed in a significant way impacting users' list tracking"
type MediaDataChangeNotification {
    "The reason for the media data change"
    context: String
    "The time the notification was created at"
    createdAt: Int
    "The id of the Notification"
    id: Int!
    "The media that received data changes"
    media: Media
    "The id of the media that received data changes"
    mediaId: Int!
    "The reason for the media data change"
    reason: String
    "The type of notification"
    type: NotificationType
}

"Notification for when a media tracked in a user's list is deleted from the site"
type MediaDeletionNotification {
    "The reason for the media deletion"
    context: String
    "The time the notification was created at"
    createdAt: Int
    "The title of the deleted media"
    deletedMediaTitle: String
    "The id of the Notification"
    id: Int!
    "The reason for the media deletion"
    reason: String
    "The type of notification"
    type: NotificationType
}

"Media connection edge"
type MediaEdge {
    "Media specific character name"
    characterName: String
    "The characters role in the media"
    characterRole: CharacterRole
    "The characters in the media voiced by the parent actor"
    characters: [Character]
    "Used for grouping roles where multiple dubs exist for the same language. Either dubbing company name or language variant."
    dubGroup: String
    "The order the media should be displayed from the users favourites"
    favouriteOrder: Int
    "The id of the connection"
    id: Int
    "If the studio is the main animation studio of the media (For Studio->MediaConnection field only)"
    isMainStudio: Boolean!
    node: Media
    "The type of relation to the parent model"
    relationType(
        "Provide 2 to use new version 2 of relation enum"
        version: Int
    ): MediaRelation
    "Notes regarding the VA's role for the character"
    roleNotes: String
    "The role of the staff member in the production of the media"
    staffRole: String
    "The voice actors of the character with role date"
    voiceActorRoles(language: StaffLanguage, sort: [StaffSort]): [StaffRoleType]
    "The voice actors of the character"
    voiceActors(language: StaffLanguage, sort: [StaffSort]): [Staff]
}

"An external link to another site related to the media"
type MediaExternalLink {
    "The id of the external link"
    id: Int!
    "The site location of the external link"
    site: String!
    "The url of the external link"
    url: String!
}

"List of anime or manga"
type MediaList {
    "Map of advanced scores with name keys"
    advancedScores: Json
    "When the entry was completed by the user"
    completedAt: FuzzyDate
    "When the entry data was created"
    createdAt: Int
    "Map of booleans for which custom lists the entry are in"
    customLists(
        "Change return structure to an array of objects"
        asArray: Boolean
    ): Json
    "If the entry shown be hidden from non-custom lists"
    hiddenFromStatusLists: Boolean
    "The id of the list entry"
    id: Int!
    media: Media
    "The id of the media"
    mediaId: Int!
    "Text notes"
    notes: String
    "Priority of planning"
    priority: Int
    "If the entry should only be visible to authenticated user"
    private: Boolean
    "The amount of episodes/chapters consumed by the user"
    progress: Int
    "The amount of volumes read by the user"
    progressVolumes: Int
    "The amount of times the user has rewatched/read the media"
    repeat: Int
    "The score of the entry"
    score(
        "Force the score to be returned in the provided format type."
        format: ScoreFormat
    ): Float
    "When the entry was started by the user"
    startedAt: FuzzyDate
    "The watching/reading status"
    status: MediaListStatus
    "When the entry data was last updated"
    updatedAt: Int
    user: User
    "The id of the user owner of the list entry"
    userId: Int!
}

"List of anime or manga"
type MediaListCollection {
    "A map of media list entry arrays grouped by custom lists"
    customLists(asArray: Boolean): [[MediaList]] @deprecated(reason: "Not GraphQL spec compliant, use lists field instead.")
    "If there is another chunk"
    hasNextChunk: Boolean
    "Grouped media list entries"
    lists: [MediaListGroup]
    "A map of media list entry arrays grouped by status"
    statusLists(asArray: Boolean): [[MediaList]] @deprecated(reason: "Not GraphQL spec compliant, use lists field instead.")
    "The owner of the list"
    user: User
}

"List group of anime or manga entries"
type MediaListGroup {
    "Media list entries"
    entries: [MediaList]
    isCustomList: Boolean
    isSplitCompletedList: Boolean
    name: String
    status: MediaListStatus
}

"A user's list options"
type MediaListOptions {
    "The user's anime list options"
    animeList: MediaListTypeOptions
    "The user's manga list options"
    mangaList: MediaListTypeOptions
    "The default order list rows should be displayed in"
    rowOrder: String
    "The score format the user is using for media lists"
    scoreFormat: ScoreFormat
    "The list theme options for both lists"
    sharedTheme: Json @deprecated(reason: "No longer used")
    "If the shared theme should be used instead of the individual list themes"
    sharedThemeEnabled: Boolean @deprecated(reason: "No longer used")
    useLegacyLists: Boolean @deprecated(reason: "No longer used")
}

"A user's list options for anime or manga lists"
type MediaListTypeOptions {
    "The names of the user's advanced scoring sections"
    advancedScoring: [String]
    "If advanced scoring is enabled"
    advancedScoringEnabled: Boolean
    "The names of the user's custom lists"
    customLists: [String]
    "The order each list should be displayed in"
    sectionOrder: [String]
    "If the completed sections of the list should be separated by format"
    splitCompletedSectionByFormat: Boolean
    "The list theme options"
    theme: Json @deprecated(reason: "This field has not yet been fully implemented and may change without warning")
}

"Notification for when a media entry is merged into another for a user who had it on their list"
type MediaMergeNotification {
    "The reason for the media data change"
    context: String
    "The time the notification was created at"
    createdAt: Int
    "The title of the deleted media"
    deletedMediaTitles: [String]
    "The id of the Notification"
    id: Int!
    "The media that was merged into"
    media: Media
    "The id of the media that was merged into"
    mediaId: Int!
    "The reason for the media merge"
    reason: String
    "The type of notification"
    type: NotificationType
}

"The ranking of a media in a particular time span and format compared to other media"
type MediaRank {
    "If the ranking is based on all time instead of a season/year"
    allTime: Boolean
    "String that gives context to the ranking type and time span"
    context: String!
    "The format the media is ranked within"
    format: MediaFormat!
    "The id of the rank"
    id: Int!
    "The numerical rank of the media"
    rank: Int!
    "The season the media is ranked within"
    season: MediaSeason
    "The type of ranking"
    type: MediaRankType!
    "The year the media is ranked within"
    year: Int
}

"A media's statistics"
type MediaStats {
    airingProgression: [AiringProgression] @deprecated(reason: "Replaced by MediaTrends")
    scoreDistribution: [ScoreDistribution]
    statusDistribution: [StatusDistribution]
}

"Data and links to legal streaming episodes on external sites"
type MediaStreamingEpisode {
    "The site location of the streaming episodes"
    site: String
    "Url of episode image thumbnail"
    thumbnail: String
    "Title of the episode"
    title: String
    "The url of the episode"
    url: String
}

"Media submission"
type MediaSubmission {
    "Data Mod assigned to handle the submission"
    assignee: User
    changes: [String]
    characters: [MediaSubmissionComparison]
    createdAt: Int
    externalLinks: [MediaExternalLink]
    "The id of the submission"
    id: Int!
    "Whether the submission is locked"
    locked: Boolean
    media: Media
    notes: String
    relations: [MediaEdge]
    source: String
    staff: [MediaSubmissionComparison]
    "Status of the submission"
    status: SubmissionStatus
    studios: [MediaSubmissionComparison]
    submission: Media
    "User submitter of the submission"
    submitter: User
    submitterStats: Json
}

"Media submission with comparison to current data"
type MediaSubmissionComparison {
    character: MediaCharacter
    staff: StaffEdge
    studio: StudioEdge
    submission: MediaSubmissionEdge
}

type MediaSubmissionEdge {
    character: Character
    characterName: String
    characterRole: CharacterRole
    characterSubmission: Character
    dubGroup: String
    "The id of the direct submission"
    id: Int
    isMain: Boolean
    media: Media
    roleNotes: String
    staff: Staff
    staffRole: String
    staffSubmission: Staff
    studio: Studio
    voiceActor: Staff
    voiceActorSubmission: Staff
}

"A tag that describes a theme or element of the media"
type MediaTag {
    "The categories of tags this tag belongs to"
    category: String
    "A general description of the tag"
    description: String
    "The id of the tag"
    id: Int!
    "If the tag is only for adult 18+ media"
    isAdult: Boolean
    "If the tag could be a spoiler for any media"
    isGeneralSpoiler: Boolean
    "If the tag is a spoiler for this media"
    isMediaSpoiler: Boolean
    "The name of the tag"
    name: String!
    "The relevance ranking of the tag out of the 100 for this media"
    rank: Int
    "The user who submitted the tag"
    userId: Int
}

"The official titles of the media in various languages"
type MediaTitle {
    "The official english title"
    english(stylised: Boolean): String
    "Official title in it's native language"
    native(stylised: Boolean): String
    "The romanization of the native language title"
    romaji(stylised: Boolean): String
    "The currently authenticated users preferred title language. Default romaji for non-authenticated"
    userPreferred: String
}

"Media trailer or advertisement"
type MediaTrailer {
    "The trailer video id"
    id: String
    "The site the video is hosted by (Currently either youtube or dailymotion)"
    site: String
    "The url for the thumbnail image of the video"
    thumbnail: String
}

"Daily media statistics"
type MediaTrend {
    "A weighted average score of all the user's scores of the media"
    averageScore: Int
    "The day the data was recorded (timestamp)"
    date: Int!
    "The episode number of the anime released on this day"
    episode: Int
    "The number of users with watching/reading the media"
    inProgress: Int
    "The related media"
    media: Media
    "The id of the tag"
    mediaId: Int!
    "The number of users with the media on their list"
    popularity: Int
    "If the media was being released at this time"
    releasing: Boolean!
    "The amount of media activity on the day"
    trending: Int!
}

type MediaTrendConnection {
    edges: [MediaTrendEdge]
    nodes: [MediaTrend]
    "The pagination information"
    pageInfo: PageInfo
}

"Media trend connection edge"
type MediaTrendEdge {
    node: MediaTrend
}

"User message activity"
type MessageActivity {
    "The time the activity was created at"
    createdAt: Int!
    "The id of the activity"
    id: Int!
    "If the currently authenticated user liked the activity"
    isLiked: Boolean
    "If the activity is locked and can receive replies"
    isLocked: Boolean
    "If the message is private and only viewable to the sender and recipients"
    isPrivate: Boolean
    "If the currently authenticated user is subscribed to the activity"
    isSubscribed: Boolean
    "The amount of likes the activity has"
    likeCount: Int!
    "The users who liked the activity"
    likes: [User]
    "The message text (Markdown)"
    message(
        "Return the string in pre-parsed html instead of markdown"
        asHtml: Boolean
    ): String
    "The user who sent the activity message"
    messenger: User
    "The user id of the activity's sender"
    messengerId: Int
    "The user who the activity message was sent to"
    recipient: User
    "The user id of the activity's recipient"
    recipientId: Int
    "The written replies to the activity"
    replies: [ActivityReply]
    "The number of activity replies"
    replyCount: Int!
    "The url for the activity page on the AniList website"
    siteUrl: String
    "The type of the activity"
    type: ActivityType
}

type ModAction {
    createdAt: Int!
    data: String
    "The id of the action"
    id: Int!
    mod: User
    objectId: Int
    objectType: String
    type: ModActionType
    user: User
}

type Mutation {
    "Delete an activity item of the authenticated users"
    DeleteActivity(
        "The id of the activity to delete"
        id: Int
    ): Deleted
    "Delete an activity reply of the authenticated users"
    DeleteActivityReply(
        "The id of the reply to delete"
        id: Int
    ): Deleted
    "Delete a custom list and remove the list entries from it"
    DeleteCustomList(
        "The name of the custom list to delete"
        customList: String,
        "The media list type of the custom list"
        type: MediaType
    ): Deleted
    "Delete a media list entry"
    DeleteMediaListEntry(
        "The id of the media list entry to delete"
        id: Int
    ): Deleted
    "Delete a review"
    DeleteReview(
        "The id of the review to delete"
        id: Int
    ): Deleted
    "Delete a thread"
    DeleteThread(
        "The id of the thread to delete"
        id: Int
    ): Deleted
    "Delete a thread comment"
    DeleteThreadComment(
        "The id of the thread comment to delete"
        id: Int
    ): Deleted
    "Rate a review"
    RateReview(
        "The rating to apply to the review"
        rating: ReviewRating,
        "The id of the review to rate"
        reviewId: Int
    ): Review
    "Create or update an activity reply"
    SaveActivityReply(
        "The id of the parent activity being replied to"
        activityId: Int,
        "If the reply should be sent from the Moderator account (Mod Only)"
        asMod: Boolean,
        "The activity reply id, required for updating"
        id: Int,
        "The reply text"
        text: String
    ): ActivityReply
    "Update list activity (Mod Only)"
    SaveListActivity(
        "The activity's id, required for updating"
        id: Int,
        "If the activity should be locked. (Mod Only)"
        locked: Boolean
    ): ListActivity
    "Create or update a media list entry"
    SaveMediaListEntry(
        "Array of advanced scores"
        advancedScores: [Float],
        "When the entry was completed by the user"
        completedAt: FuzzyDateInput,
        "Array of custom list names which should be enabled for this entry"
        customLists: [String],
        "If the entry shown be hidden from non-custom lists"
        hiddenFromStatusLists: Boolean,
        "The list entry id, required for updating"
        id: Int,
        "The id of the media the entry is of"
        mediaId: Int,
        "Text notes"
        notes: String,
        "Priority of planning"
        priority: Int,
        "If the entry should only be visible to authenticated user"
        private: Boolean,
        "The amount of episodes/chapters consumed by the user"
        progress: Int,
        "The amount of volumes read by the user"
        progressVolumes: Int,
        "The amount of times the user has rewatched/read the media"
        repeat: Int,
        "The score of the media in the user's chosen scoring method"
        score: Float,
        "The score of the media in 100 point"
        scoreRaw: Int,
        "When the entry was started by the user"
        startedAt: FuzzyDateInput,
        "The watching/reading status"
        status: MediaListStatus
    ): MediaList
    "Create or update message activity for the currently authenticated user"
    SaveMessageActivity(
        "If the message should be sent from the Moderator account (Mod Only)"
        asMod: Boolean,
        "The activity id, required for updating"
        id: Int,
        "If the activity should be locked. (Mod Only)"
        locked: Boolean,
        "The activity message text"
        message: String,
        "If the activity should be private"
        private: Boolean,
        "The id of the user the message is being sent to"
        recipientId: Int
    ): MessageActivity
    "Recommendation a media"
    SaveRecommendation(
        "The id of the base media"
        mediaId: Int,
        "The id of the media to recommend"
        mediaRecommendationId: Int,
        "The rating to give the recommendation"
        rating: RecommendationRating
    ): Recommendation
    "Create or update a review"
    SaveReview(
        "The main review text. Min:2200 characters"
        body: String,
        "The review id, required for updating"
        id: Int,
        "The id of the media the review is of"
        mediaId: Int,
        "If the review should only be visible to its creator"
        private: Boolean,
        "A short summary/preview of the review. Min:20, Max:120 characters"
        score: Int,
        "A short summary/preview of the review. Min:20, Max:120 characters"
        summary: String
    ): Review
    "Create or update text activity for the currently authenticated user"
    SaveTextActivity(
        "The activity's id, required for updating"
        id: Int,
        "If the activity should be locked. (Mod Only)"
        locked: Boolean,
        "The activity text"
        text: String
    ): TextActivity
    "Create or update a forum thread"
    SaveThread(
        "The main text body of the thread"
        body: String,
        "Forum categories the thread should be within"
        categories: [Int],
        "The thread id, required for updating"
        id: Int,
        "If the thread should be locked. (Mod Only)"
        locked: Boolean,
        "Media related to the contents of the thread"
        mediaCategories: [Int],
        "If the thread should be stickied. (Mod Only)"
        sticky: Boolean,
        "The title of the thread"
        title: String
    ): Thread
    "Create or update a thread comment"
    SaveThreadComment(
        "The comment markdown text"
        comment: String,
        "The comment id, required for updating"
        id: Int,
        "If the comment tree should be locked. (Mod Only)"
        locked: Boolean,
        "The id of thread comment to reply to"
        parentCommentId: Int,
        "The id of thread the comment belongs to"
        threadId: Int
    ): ThreadComment
    "Toggle the subscription of an activity item"
    ToggleActivitySubscription(
        "The id of the activity to un/subscribe"
        activityId: Int,
        "Whether to subscribe or unsubscribe from the activity"
        subscribe: Boolean
    ): ActivityUnion
    "Favourite or unfavourite an anime, manga, character, staff member, or studio"
    ToggleFavourite(
        "The id of the anime to un/favourite"
        animeId: Int,
        "The id of the character to un/favourite"
        characterId: Int,
        "The id of the manga to un/favourite"
        mangaId: Int,
        "The id of the staff to un/favourite"
        staffId: Int,
        "The id of the studio to un/favourite"
        studioId: Int
    ): Favourites
    "Toggle the un/following of a user"
    ToggleFollow(
        "The id of the user to un/follow"
        userId: Int
    ): User
    """

    Add or remove a like from a likeable type.
    Returns all the users who liked the same model
    """
    ToggleLike(
        "The id of the likeable type"
        id: Int,
        "The type of model to be un/liked"
        type: LikeableType
    ): [User]
    "Add or remove a like from a likeable type."
    ToggleLikeV2(
        "The id of the likeable type"
        id: Int,
        "The type of model to be un/liked"
        type: LikeableType
    ): LikeableUnion
    "Toggle the subscription of a forum thread"
    ToggleThreadSubscription(
        "Whether to subscribe or unsubscribe from the forum thread"
        subscribe: Boolean,
        "The id of the forum thread to un/subscribe"
        threadId: Int
    ): Thread
    UpdateAniChartHighlights(highlights: [AniChartHighlightInput]): Json
    UpdateAniChartSettings(outgoingLinkProvider: String, sort: String, theme: String, titleLanguage: String): Json
    "Update the order favourites are displayed in"
    UpdateFavouriteOrder(
        "The id of the anime to un/favourite"
        animeIds: [Int],
        "List of integers which the anime should be ordered by (Asc)"
        animeOrder: [Int],
        "The id of the character to un/favourite"
        characterIds: [Int],
        "List of integers which the character should be ordered by (Asc)"
        characterOrder: [Int],
        "The id of the manga to un/favourite"
        mangaIds: [Int],
        "List of integers which the manga should be ordered by (Asc)"
        mangaOrder: [Int],
        "The id of the staff to un/favourite"
        staffIds: [Int],
        "List of integers which the staff should be ordered by (Asc)"
        staffOrder: [Int],
        "The id of the studio to un/favourite"
        studioIds: [Int],
        "List of integers which the studio should be ordered by (Asc)"
        studioOrder: [Int]
    ): Favourites
    "Update multiple media list entries to the same values"
    UpdateMediaListEntries(
        "Array of advanced scores"
        advancedScores: [Float],
        "When the entry was completed by the user"
        completedAt: FuzzyDateInput,
        "If the entry shown be hidden from non-custom lists"
        hiddenFromStatusLists: Boolean,
        "The list entries ids to update"
        ids: [Int],
        "Text notes"
        notes: String,
        "Priority of planning"
        priority: Int,
        "If the entry should only be visible to authenticated user"
        private: Boolean,
        "The amount of episodes/chapters consumed by the user"
        progress: Int,
        "The amount of volumes read by the user"
        progressVolumes: Int,
        "The amount of times the user has rewatched/read the media"
        repeat: Int,
        "The score of the media in the user's chosen scoring method"
        score: Float,
        "The score of the media in 100 point"
        scoreRaw: Int,
        "When the entry was started by the user"
        startedAt: FuzzyDateInput,
        "The watching/reading status"
        status: MediaListStatus
    ): [MediaList]
    UpdateUser(
        "User's about/bio text"
        about: String,
        "Minutes between activity for them to be merged together. 0 is Never, Above 2 weeks (20160 mins) is Always."
        activityMergeTime: Int,
        "If the user should get notifications when a show they are watching aires"
        airingNotifications: Boolean,
        "The user's anime list options"
        animeListOptions: MediaListOptionsInput,
        "If the user should see media marked as adult-only"
        displayAdultContent: Boolean,
        "Profile highlight color"
        donatorBadge: String,
        "The user's anime list options"
        mangaListOptions: MediaListOptionsInput,
        "Notification options"
        notificationOptions: [NotificationOptionInput],
        "Profile highlight color"
        profileColor: String,
        "The user's default list order"
        rowOrder: String,
        "The user's list scoring system"
        scoreFormat: ScoreFormat,
        "The language the user wants to see staff and character names in"
        staffNameLanguage: UserStaffNameLanguage,
        "Timezone offset format: -?HH:MM"
        timezone: String,
        "User's title language"
        titleLanguage: UserTitleLanguage
    ): User
}

"Notification option"
type NotificationOption {
    "Whether this type of notification is enabled"
    enabled: Boolean
    "The type of notification"
    type: NotificationType
}

"Page of data"
type Page {
    activities(
        "Filter by the time the activity was created"
        createdAt: Int,
        "Filter by the time the activity was created"
        createdAt_greater: Int,
        "Filter by the time the activity was created"
        createdAt_lesser: Int,
        "Filter activity to only activity with replies"
        hasReplies: Boolean,
        "Filter activity to only activity with replies or is of type text"
        hasRepliesOrTypeText: Boolean,
        "Filter by the activity id"
        id: Int,
        "Filter by the activity id"
        id_in: [Int],
        "Filter by the activity id"
        id_not: Int,
        "Filter by the activity id"
        id_not_in: [Int],
        "Filter activity to users who are being followed by the authenticated user"
        isFollowing: Boolean,
        "Filter by the associated media id of the activity"
        mediaId: Int,
        "Filter by the associated media id of the activity"
        mediaId_in: [Int],
        "Filter by the associated media id of the activity"
        mediaId_not: Int,
        "Filter by the associated media id of the activity"
        mediaId_not_in: [Int],
        "Filter by the id of the user who sent a message"
        messengerId: Int,
        "Filter by the id of the user who sent a message"
        messengerId_in: [Int],
        "Filter by the id of the user who sent a message"
        messengerId_not: Int,
        "Filter by the id of the user who sent a message"
        messengerId_not_in: [Int],
        "The order the results will be returned in"
        sort: [ActivitySort],
        "Filter by the type of activity"
        type: ActivityType,
        "Filter by the type of activity"
        type_in: [ActivityType],
        "Filter by the type of activity"
        type_not: ActivityType,
        "Filter by the type of activity"
        type_not_in: [ActivityType],
        "Filter by the owner user id"
        userId: Int,
        "Filter by the owner user id"
        userId_in: [Int],
        "Filter by the owner user id"
        userId_not: Int,
        "Filter by the owner user id"
        userId_not_in: [Int]
    ): [ActivityUnion]
    activityReplies(
        "Filter by the parent id"
        activityId: Int,
        "Filter by the reply id"
        id: Int
    ): [ActivityReply]
    airingSchedules(
        "Filter by the time of airing"
        airingAt: Int,
        "Filter by the time of airing"
        airingAt_greater: Int,
        "Filter by the time of airing"
        airingAt_lesser: Int,
        "Filter by the airing episode number"
        episode: Int,
        "Filter by the airing episode number"
        episode_greater: Int,
        "Filter by the airing episode number"
        episode_in: [Int],
        "Filter by the airing episode number"
        episode_lesser: Int,
        "Filter by the airing episode number"
        episode_not: Int,
        "Filter by the airing episode number"
        episode_not_in: [Int],
        "Filter by the id of the airing schedule item"
        id: Int,
        "Filter by the id of the airing schedule item"
        id_in: [Int],
        "Filter by the id of the airing schedule item"
        id_not: Int,
        "Filter by the id of the airing schedule item"
        id_not_in: [Int],
        "Filter by the id of associated media"
        mediaId: Int,
        "Filter by the id of associated media"
        mediaId_in: [Int],
        "Filter by the id of associated media"
        mediaId_not: Int,
        "Filter by the id of associated media"
        mediaId_not_in: [Int],
        "Filter to episodes that haven't yet aired"
        notYetAired: Boolean,
        "The order the results will be returned in"
        sort: [AiringSort]
    ): [AiringSchedule]
    characters(
        "Filter by character id"
        id: Int,
        "Filter by character id"
        id_in: [Int],
        "Filter by character id"
        id_not: Int,
        "Filter by character id"
        id_not_in: [Int],
        "Filter by character by if its their birthday today"
        isBirthday: Boolean,
        "Filter by search query"
        search: String,
        "The order the results will be returned in"
        sort: [CharacterSort]
    ): [Character]
    followers(
        "The order the results will be returned in"
        sort: [UserSort],
        "User id of the follower/followed"
        userId: Int!
    ): [User]
    following(
        "The order the results will be returned in"
        sort: [UserSort],
        "User id of the follower/followed"
        userId: Int!
    ): [User]
    likes(
        "The id of the likeable type"
        likeableId: Int,
        "The type of model the id applies to"
        type: LikeableType
    ): [User]
    media(
        "Filter by the media's average score"
        averageScore: Int,
        "Filter by the media's average score"
        averageScore_greater: Int,
        "Filter by the media's average score"
        averageScore_lesser: Int,
        "Filter by the media's average score"
        averageScore_not: Int,
        "Filter by the media's chapter count"
        chapters: Int,
        "Filter by the media's chapter count"
        chapters_greater: Int,
        "Filter by the media's chapter count"
        chapters_lesser: Int,
        "Filter by the media's country of origin"
        countryOfOrigin: CountryCode,
        "Filter by the media's episode length"
        duration: Int,
        "Filter by the media's episode length"
        duration_greater: Int,
        "Filter by the media's episode length"
        duration_lesser: Int,
        "Filter by the end date of the media"
        endDate: FuzzyDateInt,
        "Filter by the end date of the media"
        endDate_greater: FuzzyDateInt,
        "Filter by the end date of the media"
        endDate_lesser: FuzzyDateInt,
        "Filter by the end date of the media"
        endDate_like: String,
        "Filter by amount of episodes the media has"
        episodes: Int,
        "Filter by amount of episodes the media has"
        episodes_greater: Int,
        "Filter by amount of episodes the media has"
        episodes_lesser: Int,
        "Filter by the media's format"
        format: MediaFormat,
        "Filter by the media's format"
        format_in: [MediaFormat],
        "Filter by the media's format"
        format_not: MediaFormat,
        "Filter by the media's format"
        format_not_in: [MediaFormat],
        "Filter by the media's genres"
        genre: String,
        "Filter by the media's genres"
        genre_in: [String],
        "Filter by the media's genres"
        genre_not_in: [String],
        "Filter by the media id"
        id: Int,
        "Filter by the media's MyAnimeList id"
        idMal: Int,
        "Filter by the media's MyAnimeList id"
        idMal_in: [Int],
        "Filter by the media's MyAnimeList id"
        idMal_not: Int,
        "Filter by the media's MyAnimeList id"
        idMal_not_in: [Int],
        "Filter by the media id"
        id_in: [Int],
        "Filter by the media id"
        id_not: Int,
        "Filter by the media id"
        id_not_in: [Int],
        "Filter by if the media's intended for 18+ adult audiences"
        isAdult: Boolean,
        "If the media is officially licensed or a self-published doujin release"
        isLicensed: Boolean,
        "Filter media by sites with a online streaming or reading license"
        licensedBy: String,
        "Filter media by sites with a online streaming or reading license"
        licensedBy_in: [String],
        "Only apply the tags filter argument to tags above this rank. Default: 18"
        minimumTagRank: Int,
        "Filter by the media on the authenticated user's lists"
        onList: Boolean,
        "Filter by the number of users with this media on their list"
        popularity: Int,
        "Filter by the number of users with this media on their list"
        popularity_greater: Int,
        "Filter by the number of users with this media on their list"
        popularity_lesser: Int,
        "Filter by the number of users with this media on their list"
        popularity_not: Int,
        "Filter by search query"
        search: String,
        "Filter by the season the media was released in"
        season: MediaSeason,
        "The year of the season (Winter 2017 would also include December 2016 releases). Requires season argument"
        seasonYear: Int,
        "The order the results will be returned in"
        sort: [MediaSort],
        "Filter by the source type of the media"
        source: MediaSource,
        "Filter by the source type of the media"
        source_in: [MediaSource],
        "Filter by the start date of the media"
        startDate: FuzzyDateInt,
        "Filter by the start date of the media"
        startDate_greater: FuzzyDateInt,
        "Filter by the start date of the media"
        startDate_lesser: FuzzyDateInt,
        "Filter by the start date of the media"
        startDate_like: String,
        "Filter by the media's current release status"
        status: MediaStatus,
        "Filter by the media's current release status"
        status_in: [MediaStatus],
        "Filter by the media's current release status"
        status_not: MediaStatus,
        "Filter by the media's current release status"
        status_not_in: [MediaStatus],
        "Filter by the media's tags"
        tag: String,
        "Filter by the media's tags with in a tag category"
        tagCategory: String,
        "Filter by the media's tags with in a tag category"
        tagCategory_in: [String],
        "Filter by the media's tags with in a tag category"
        tagCategory_not_in: [String],
        "Filter by the media's tags"
        tag_in: [String],
        "Filter by the media's tags"
        tag_not_in: [String],
        "Filter by the media's type"
        type: MediaType,
        "Filter by the media's volume count"
        volumes: Int,
        "Filter by the media's volume count"
        volumes_greater: Int,
        "Filter by the media's volume count"
        volumes_lesser: Int
    ): [Media]
    mediaList(
        "Limit to only entries also on the auth user's list. Requires user id or name arguments."
        compareWithAuthList: Boolean,
        "Filter by the date the user completed the media"
        completedAt: FuzzyDateInt,
        "Filter by the date the user completed the media"
        completedAt_greater: FuzzyDateInt,
        "Filter by the date the user completed the media"
        completedAt_lesser: FuzzyDateInt,
        "Filter by the date the user completed the media"
        completedAt_like: String,
        "Filter by a list entry's id"
        id: Int,
        "Filter list entries to users who are being followed by the authenticated user"
        isFollowing: Boolean,
        "Filter by the media id of the list entry"
        mediaId: Int,
        "Filter by the media id of the list entry"
        mediaId_in: [Int],
        "Filter by the media id of the list entry"
        mediaId_not_in: [Int],
        "Filter by note words and #tags"
        notes: String,
        "Filter by note words and #tags"
        notes_like: String,
        "The order the results will be returned in"
        sort: [MediaListSort],
        "Filter by the date the user started the media"
        startedAt: FuzzyDateInt,
        "Filter by the date the user started the media"
        startedAt_greater: FuzzyDateInt,
        "Filter by the date the user started the media"
        startedAt_lesser: FuzzyDateInt,
        "Filter by the date the user started the media"
        startedAt_like: String,
        "Filter by the watching/reading status"
        status: MediaListStatus,
        "Filter by the watching/reading status"
        status_in: [MediaListStatus],
        "Filter by the watching/reading status"
        status_not: MediaListStatus,
        "Filter by the watching/reading status"
        status_not_in: [MediaListStatus],
        "Filter by the list entries media type"
        type: MediaType,
        "Filter by a user's id"
        userId: Int,
        "Filter by a user's id"
        userId_in: [Int],
        "Filter by a user's name"
        userName: String
    ): [MediaList]
    mediaTrends(
        "Filter by score"
        averageScore: Int,
        "Filter by score"
        averageScore_greater: Int,
        "Filter by score"
        averageScore_lesser: Int,
        "Filter by score"
        averageScore_not: Int,
        "Filter by date"
        date: Int,
        "Filter by date"
        date_greater: Int,
        "Filter by date"
        date_lesser: Int,
        "Filter by episode number"
        episode: Int,
        "Filter by episode number"
        episode_greater: Int,
        "Filter by episode number"
        episode_lesser: Int,
        "Filter by episode number"
        episode_not: Int,
        "Filter by the media id"
        mediaId: Int,
        "Filter by the media id"
        mediaId_in: [Int],
        "Filter by the media id"
        mediaId_not: Int,
        "Filter by the media id"
        mediaId_not_in: [Int],
        "Filter by popularity"
        popularity: Int,
        "Filter by popularity"
        popularity_greater: Int,
        "Filter by popularity"
        popularity_lesser: Int,
        "Filter by popularity"
        popularity_not: Int,
        "Filter to stats recorded while the media was releasing"
        releasing: Boolean,
        "The order the results will be returned in"
        sort: [MediaTrendSort],
        "Filter by trending amount"
        trending: Int,
        "Filter by trending amount"
        trending_greater: Int,
        "Filter by trending amount"
        trending_lesser: Int,
        "Filter by trending amount"
        trending_not: Int
    ): [MediaTrend]
    notifications(
        "Reset the unread notification count to 0 on load"
        resetNotificationCount: Boolean,
        "Filter by the type of notifications"
        type: NotificationType,
        "Filter by the type of notifications"
        type_in: [NotificationType]
    ): [NotificationUnion]
    "The pagination information"
    pageInfo: PageInfo
    recommendations(
        "Filter by recommendation id"
        id: Int,
        "Filter by media id"
        mediaId: Int,
        "Filter by media recommendation id"
        mediaRecommendationId: Int,
        "Filter by the media on the authenticated user's lists"
        onList: Boolean,
        "Filter by total rating of the recommendation"
        rating: Int,
        "Filter by total rating of the recommendation"
        rating_greater: Int,
        "Filter by total rating of the recommendation"
        rating_lesser: Int,
        "The order the results will be returned in"
        sort: [RecommendationSort],
        "Filter by user who created the recommendation"
        userId: Int
    ): [Recommendation]
    reviews(
        "Filter by Review id"
        id: Int,
        "Filter by media id"
        mediaId: Int,
        "Filter by media type"
        mediaType: MediaType,
        "The order the results will be returned in"
        sort: [ReviewSort],
        "Filter by user id"
        userId: Int
    ): [Review]
    staff(
        "Filter by the staff id"
        id: Int,
        "Filter by the staff id"
        id_in: [Int],
        "Filter by the staff id"
        id_not: Int,
        "Filter by the staff id"
        id_not_in: [Int],
        "Filter by staff by if its their birthday today"
        isBirthday: Boolean,
        "Filter by search query"
        search: String,
        "The order the results will be returned in"
        sort: [StaffSort]
    ): [Staff]
    studios(
        "Filter by the studio id"
        id: Int,
        "Filter by the studio id"
        id_in: [Int],
        "Filter by the studio id"
        id_not: Int,
        "Filter by the studio id"
        id_not_in: [Int],
        "Filter by search query"
        search: String,
        "The order the results will be returned in"
        sort: [StudioSort]
    ): [Studio]
    threadComments(
        "Filter by the comment id"
        id: Int,
        "The order the results will be returned in"
        sort: [ThreadCommentSort],
        "Filter by the thread id"
        threadId: Int,
        "Filter by the user id of the comment's creator"
        userId: Int
    ): [ThreadComment]
    threads(
        "Filter by thread category id"
        categoryId: Int,
        "Filter by the thread id"
        id: Int,
        "Filter by the thread id"
        id_in: [Int],
        "Filter by thread media id category"
        mediaCategoryId: Int,
        "Filter by the user id of the last user to comment on the thread"
        replyUserId: Int,
        "Filter by search query"
        search: String,
        "The order the results will be returned in"
        sort: [ThreadSort],
        "Filter by if the currently authenticated user's subscribed threads"
        subscribed: Boolean,
        "Filter by the user id of the thread's creator"
        userId: Int
    ): [Thread]
    users(
        "Filter by the user id"
        id: Int,
        "Filter to moderators only if true"
        isModerator: Boolean,
        "Filter by the name of the user"
        name: String,
        "Filter by search query"
        search: String,
        "The order the results will be returned in"
        sort: [UserSort]
    ): [User]
}

type PageInfo {
    "The current page"
    currentPage: Int
    "If there is another page"
    hasNextPage: Boolean
    "The last page"
    lastPage: Int
    "The count on a page"
    perPage: Int
    "The total number of items. Note: This value is not guaranteed to be accurate, do not rely on this for logic"
    total: Int
}

"Provides the parsed markdown as html"
type ParsedMarkdown {
    "The parsed markdown as html"
    html: String
}

type Query {
    "Activity query"
    Activity(
        "Filter by the time the activity was created"
        createdAt: Int,
        "Filter by the time the activity was created"
        createdAt_greater: Int,
        "Filter by the time the activity was created"
        createdAt_lesser: Int,
        "Filter activity to only activity with replies"
        hasReplies: Boolean,
        "Filter activity to only activity with replies or is of type text"
        hasRepliesOrTypeText: Boolean,
        "Filter by the activity id"
        id: Int,
        "Filter by the activity id"
        id_in: [Int],
        "Filter by the activity id"
        id_not: Int,
        "Filter by the activity id"
        id_not_in: [Int],
        "Filter activity to users who are being followed by the authenticated user"
        isFollowing: Boolean,
        "Filter by the associated media id of the activity"
        mediaId: Int,
        "Filter by the associated media id of the activity"
        mediaId_in: [Int],
        "Filter by the associated media id of the activity"
        mediaId_not: Int,
        "Filter by the associated media id of the activity"
        mediaId_not_in: [Int],
        "Filter by the id of the user who sent a message"
        messengerId: Int,
        "Filter by the id of the user who sent a message"
        messengerId_in: [Int],
        "Filter by the id of the user who sent a message"
        messengerId_not: Int,
        "Filter by the id of the user who sent a message"
        messengerId_not_in: [Int],
        "The order the results will be returned in"
        sort: [ActivitySort],
        "Filter by the type of activity"
        type: ActivityType,
        "Filter by the type of activity"
        type_in: [ActivityType],
        "Filter by the type of activity"
        type_not: ActivityType,
        "Filter by the type of activity"
        type_not_in: [ActivityType],
        "Filter by the owner user id"
        userId: Int,
        "Filter by the owner user id"
        userId_in: [Int],
        "Filter by the owner user id"
        userId_not: Int,
        "Filter by the owner user id"
        userId_not_in: [Int]
    ): ActivityUnion
    "Activity reply query"
    ActivityReply(
        "Filter by the parent id"
        activityId: Int,
        "Filter by the reply id"
        id: Int
    ): ActivityReply
    "Airing schedule query"
    AiringSchedule(
        "Filter by the time of airing"
        airingAt: Int,
        "Filter by the time of airing"
        airingAt_greater: Int,
        "Filter by the time of airing"
        airingAt_lesser: Int,
        "Filter by the airing episode number"
        episode: Int,
        "Filter by the airing episode number"
        episode_greater: Int,
        "Filter by the airing episode number"
        episode_in: [Int],
        "Filter by the airing episode number"
        episode_lesser: Int,
        "Filter by the airing episode number"
        episode_not: Int,
        "Filter by the airing episode number"
        episode_not_in: [Int],
        "Filter by the id of the airing schedule item"
        id: Int,
        "Filter by the id of the airing schedule item"
        id_in: [Int],
        "Filter by the id of the airing schedule item"
        id_not: Int,
        "Filter by the id of the airing schedule item"
        id_not_in: [Int],
        "Filter by the id of associated media"
        mediaId: Int,
        "Filter by the id of associated media"
        mediaId_in: [Int],
        "Filter by the id of associated media"
        mediaId_not: Int,
        "Filter by the id of associated media"
        mediaId_not_in: [Int],
        "Filter to episodes that haven't yet aired"
        notYetAired: Boolean,
        "The order the results will be returned in"
        sort: [AiringSort]
    ): AiringSchedule
    AniChartUser: AniChartUser
    "Character query"
    Character(
        "Filter by character id"
        id: Int,
        "Filter by character id"
        id_in: [Int],
        "Filter by character id"
        id_not: Int,
        "Filter by character id"
        id_not_in: [Int],
        "Filter by character by if its their birthday today"
        isBirthday: Boolean,
        "Filter by search query"
        search: String,
        "The order the results will be returned in"
        sort: [CharacterSort]
    ): Character
    "Follow query"
    Follower(
        "The order the results will be returned in"
        sort: [UserSort],
        "User id of the follower/followed"
        userId: Int!
    ): User
    "Follow query"
    Following(
        "The order the results will be returned in"
        sort: [UserSort],
        "User id of the follower/followed"
        userId: Int!
    ): User
    "Collection of all the possible media genres"
    GenreCollection: [String]
    "Like query"
    Like(
        "The id of the likeable type"
        likeableId: Int,
        "The type of model the id applies to"
        type: LikeableType
    ): User
    "Provide AniList markdown to be converted to html (Requires auth)"
    Markdown(
        "The markdown to be parsed to html"
        markdown: String!
    ): ParsedMarkdown
    "Media query"
    Media(
        "Filter by the media's average score"
        averageScore: Int,
        "Filter by the media's average score"
        averageScore_greater: Int,
        "Filter by the media's average score"
        averageScore_lesser: Int,
        "Filter by the media's average score"
        averageScore_not: Int,
        "Filter by the media's chapter count"
        chapters: Int,
        "Filter by the media's chapter count"
        chapters_greater: Int,
        "Filter by the media's chapter count"
        chapters_lesser: Int,
        "Filter by the media's country of origin"
        countryOfOrigin: CountryCode,
        "Filter by the media's episode length"
        duration: Int,
        "Filter by the media's episode length"
        duration_greater: Int,
        "Filter by the media's episode length"
        duration_lesser: Int,
        "Filter by the end date of the media"
        endDate: FuzzyDateInt,
        "Filter by the end date of the media"
        endDate_greater: FuzzyDateInt,
        "Filter by the end date of the media"
        endDate_lesser: FuzzyDateInt,
        "Filter by the end date of the media"
        endDate_like: String,
        "Filter by amount of episodes the media has"
        episodes: Int,
        "Filter by amount of episodes the media has"
        episodes_greater: Int,
        "Filter by amount of episodes the media has"
        episodes_lesser: Int,
        "Filter by the media's format"
        format: MediaFormat,
        "Filter by the media's format"
        format_in: [MediaFormat],
        "Filter by the media's format"
        format_not: MediaFormat,
        "Filter by the media's format"
        format_not_in: [MediaFormat],
        "Filter by the media's genres"
        genre: String,
        "Filter by the media's genres"
        genre_in: [String],
        "Filter by the media's genres"
        genre_not_in: [String],
        "Filter by the media id"
        id: Int,
        "Filter by the media's MyAnimeList id"
        idMal: Int,
        "Filter by the media's MyAnimeList id"
        idMal_in: [Int],
        "Filter by the media's MyAnimeList id"
        idMal_not: Int,
        "Filter by the media's MyAnimeList id"
        idMal_not_in: [Int],
        "Filter by the media id"
        id_in: [Int],
        "Filter by the media id"
        id_not: Int,
        "Filter by the media id"
        id_not_in: [Int],
        "Filter by if the media's intended for 18+ adult audiences"
        isAdult: Boolean,
        "If the media is officially licensed or a self-published doujin release"
        isLicensed: Boolean,
        "Filter media by sites with a online streaming or reading license"
        licensedBy: String,
        "Filter media by sites with a online streaming or reading license"
        licensedBy_in: [String],
        "Only apply the tags filter argument to tags above this rank. Default: 18"
        minimumTagRank: Int,
        "Filter by the media on the authenticated user's lists"
        onList: Boolean,
        "Filter by the number of users with this media on their list"
        popularity: Int,
        "Filter by the number of users with this media on their list"
        popularity_greater: Int,
        "Filter by the number of users with this media on their list"
        popularity_lesser: Int,
        "Filter by the number of users with this media on their list"
        popularity_not: Int,
        "Filter by search query"
        search: String,
        "Filter by the season the media was released in"
        season: MediaSeason,
        "The year of the season (Winter 2017 would also include December 2016 releases). Requires season argument"
        seasonYear: Int,
        "The order the results will be returned in"
        sort: [MediaSort],
        "Filter by the source type of the media"
        source: MediaSource,
        "Filter by the source type of the media"
        source_in: [MediaSource],
        "Filter by the start date of the media"
        startDate: FuzzyDateInt,
        "Filter by the start date of the media"
        startDate_greater: FuzzyDateInt,
        "Filter by the start date of the media"
        startDate_lesser: FuzzyDateInt,
        "Filter by the start date of the media"
        startDate_like: String,
        "Filter by the media's current release status"
        status: MediaStatus,
        "Filter by the media's current release status"
        status_in: [MediaStatus],
        "Filter by the media's current release status"
        status_not: MediaStatus,
        "Filter by the media's current release status"
        status_not_in: [MediaStatus],
        "Filter by the media's tags"
        tag: String,
        "Filter by the media's tags with in a tag category"
        tagCategory: String,
        "Filter by the media's tags with in a tag category"
        tagCategory_in: [String],
        "Filter by the media's tags with in a tag category"
        tagCategory_not_in: [String],
        "Filter by the media's tags"
        tag_in: [String],
        "Filter by the media's tags"
        tag_not_in: [String],
        "Filter by the media's type"
        type: MediaType,
        "Filter by the media's volume count"
        volumes: Int,
        "Filter by the media's volume count"
        volumes_greater: Int,
        "Filter by the media's volume count"
        volumes_lesser: Int
    ): Media
    "Media list query"
    MediaList(
        "Limit to only entries also on the auth user's list. Requires user id or name arguments."
        compareWithAuthList: Boolean,
        "Filter by the date the user completed the media"
        completedAt: FuzzyDateInt,
        "Filter by the date the user completed the media"
        completedAt_greater: FuzzyDateInt,
        "Filter by the date the user completed the media"
        completedAt_lesser: FuzzyDateInt,
        "Filter by the date the user completed the media"
        completedAt_like: String,
        "Filter by a list entry's id"
        id: Int,
        "Filter list entries to users who are being followed by the authenticated user"
        isFollowing: Boolean,
        "Filter by the media id of the list entry"
        mediaId: Int,
        "Filter by the media id of the list entry"
        mediaId_in: [Int],
        "Filter by the media id of the list entry"
        mediaId_not_in: [Int],
        "Filter by note words and #tags"
        notes: String,
        "Filter by note words and #tags"
        notes_like: String,
        "The order the results will be returned in"
        sort: [MediaListSort],
        "Filter by the date the user started the media"
        startedAt: FuzzyDateInt,
        "Filter by the date the user started the media"
        startedAt_greater: FuzzyDateInt,
        "Filter by the date the user started the media"
        startedAt_lesser: FuzzyDateInt,
        "Filter by the date the user started the media"
        startedAt_like: String,
        "Filter by the watching/reading status"
        status: MediaListStatus,
        "Filter by the watching/reading status"
        status_in: [MediaListStatus],
        "Filter by the watching/reading status"
        status_not: MediaListStatus,
        "Filter by the watching/reading status"
        status_not_in: [MediaListStatus],
        "Filter by the list entries media type"
        type: MediaType,
        "Filter by a user's id"
        userId: Int,
        "Filter by a user's id"
        userId_in: [Int],
        "Filter by a user's name"
        userName: String
    ): MediaList
    "Media list collection query, provides list pre-grouped by status & custom lists. User ID and Media Type arguments required."
    MediaListCollection(
        "Which chunk of list entries to load"
        chunk: Int,
        "Filter by the date the user completed the media"
        completedAt: FuzzyDateInt,
        "Filter by the date the user completed the media"
        completedAt_greater: FuzzyDateInt,
        "Filter by the date the user completed the media"
        completedAt_lesser: FuzzyDateInt,
        "Filter by the date the user completed the media"
        completedAt_like: String,
        "Always return completed list entries in one group, overriding the user's split completed option."
        forceSingleCompletedList: Boolean,
        "Filter by note words and #tags"
        notes: String,
        "Filter by note words and #tags"
        notes_like: String,
        "The amount of entries per chunk, max 500"
        perChunk: Int,
        "The order the results will be returned in"
        sort: [MediaListSort],
        "Filter by the date the user started the media"
        startedAt: FuzzyDateInt,
        "Filter by the date the user started the media"
        startedAt_greater: FuzzyDateInt,
        "Filter by the date the user started the media"
        startedAt_lesser: FuzzyDateInt,
        "Filter by the date the user started the media"
        startedAt_like: String,
        "Filter by the watching/reading status"
        status: MediaListStatus,
        "Filter by the watching/reading status"
        status_in: [MediaListStatus],
        "Filter by the watching/reading status"
        status_not: MediaListStatus,
        "Filter by the watching/reading status"
        status_not_in: [MediaListStatus],
        "Filter by the list entries media type"
        type: MediaType,
        "Filter by a user's id"
        userId: Int,
        "Filter by a user's name"
        userName: String
    ): MediaListCollection
    "Collection of all the possible media tags"
    MediaTagCollection(
        "Mod Only"
        status: Int
    ): [MediaTag]
    "Media Trend query"
    MediaTrend(
        "Filter by score"
        averageScore: Int,
        "Filter by score"
        averageScore_greater: Int,
        "Filter by score"
        averageScore_lesser: Int,
        "Filter by score"
        averageScore_not: Int,
        "Filter by date"
        date: Int,
        "Filter by date"
        date_greater: Int,
        "Filter by date"
        date_lesser: Int,
        "Filter by episode number"
        episode: Int,
        "Filter by episode number"
        episode_greater: Int,
        "Filter by episode number"
        episode_lesser: Int,
        "Filter by episode number"
        episode_not: Int,
        "Filter by the media id"
        mediaId: Int,
        "Filter by the media id"
        mediaId_in: [Int],
        "Filter by the media id"
        mediaId_not: Int,
        "Filter by the media id"
        mediaId_not_in: [Int],
        "Filter by popularity"
        popularity: Int,
        "Filter by popularity"
        popularity_greater: Int,
        "Filter by popularity"
        popularity_lesser: Int,
        "Filter by popularity"
        popularity_not: Int,
        "Filter to stats recorded while the media was releasing"
        releasing: Boolean,
        "The order the results will be returned in"
        sort: [MediaTrendSort],
        "Filter by trending amount"
        trending: Int,
        "Filter by trending amount"
        trending_greater: Int,
        "Filter by trending amount"
        trending_lesser: Int,
        "Filter by trending amount"
        trending_not: Int
    ): MediaTrend
    "Notification query"
    Notification(
        "Reset the unread notification count to 0 on load"
        resetNotificationCount: Boolean,
        "Filter by the type of notifications"
        type: NotificationType,
        "Filter by the type of notifications"
        type_in: [NotificationType]
    ): NotificationUnion
    Page(
        "The page number"
        page: Int,
        "The amount of entries per page, max 50"
        perPage: Int
    ): Page
    "Recommendation query"
    Recommendation(
        "Filter by recommendation id"
        id: Int,
        "Filter by media id"
        mediaId: Int,
        "Filter by media recommendation id"
        mediaRecommendationId: Int,
        "Filter by the media on the authenticated user's lists"
        onList: Boolean,
        "Filter by total rating of the recommendation"
        rating: Int,
        "Filter by total rating of the recommendation"
        rating_greater: Int,
        "Filter by total rating of the recommendation"
        rating_lesser: Int,
        "The order the results will be returned in"
        sort: [RecommendationSort],
        "Filter by user who created the recommendation"
        userId: Int
    ): Recommendation
    "Review query"
    Review(
        "Filter by Review id"
        id: Int,
        "Filter by media id"
        mediaId: Int,
        "Filter by media type"
        mediaType: MediaType,
        "The order the results will be returned in"
        sort: [ReviewSort],
        "Filter by user id"
        userId: Int
    ): Review
    "Site statistics query"
    SiteStatistics: SiteStatistics
    "Staff query"
    Staff(
        "Filter by the staff id"
        id: Int,
        "Filter by the staff id"
        id_in: [Int],
        "Filter by the staff id"
        id_not: Int,
        "Filter by the staff id"
        id_not_in: [Int],
        "Filter by staff by if its their birthday today"
        isBirthday: Boolean,
        "Filter by search query"
        search: String,
        "The order the results will be returned in"
        sort: [StaffSort]
    ): Staff
    "Studio query"
    Studio(
        "Filter by the studio id"
        id: Int,
        "Filter by the studio id"
        id_in: [Int],
        "Filter by the studio id"
        id_not: Int,
        "Filter by the studio id"
        id_not_in: [Int],
        "Filter by search query"
        search: String,
        "The order the results will be returned in"
        sort: [StudioSort]
    ): Studio
    "Thread query"
    Thread(
        "Filter by thread category id"
        categoryId: Int,
        "Filter by the thread id"
        id: Int,
        "Filter by the thread id"
        id_in: [Int],
        "Filter by thread media id category"
        mediaCategoryId: Int,
        "Filter by the user id of the last user to comment on the thread"
        replyUserId: Int,
        "Filter by search query"
        search: String,
        "The order the results will be returned in"
        sort: [ThreadSort],
        "Filter by if the currently authenticated user's subscribed threads"
        subscribed: Boolean,
        "Filter by the user id of the thread's creator"
        userId: Int
    ): Thread
    "Comment query"
    ThreadComment(
        "Filter by the comment id"
        id: Int,
        "The order the results will be returned in"
        sort: [ThreadCommentSort],
        "Filter by the thread id"
        threadId: Int,
        "Filter by the user id of the comment's creator"
        userId: Int
    ): [ThreadComment]
    "User query"
    User(
        "Filter by the user id"
        id: Int,
        "Filter to moderators only if true"
        isModerator: Boolean,
        "Filter by the name of the user"
        name: String,
        "Filter by search query"
        search: String,
        "The order the results will be returned in"
        sort: [UserSort]
    ): User
    "Get the currently authenticated user"
    Viewer: User
}

"Media recommendation"
type Recommendation {
    "The id of the recommendation"
    id: Int!
    "The media the recommendation is from"
    media: Media
    "The recommended media"
    mediaRecommendation: Media
    "Users rating of the recommendation"
    rating: Int
    "The user that first created the recommendation"
    user: User
    "The rating of the recommendation by currently authenticated user"
    userRating: RecommendationRating
}

type RecommendationConnection {
    edges: [RecommendationEdge]
    nodes: [Recommendation]
    "The pagination information"
    pageInfo: PageInfo
}

"Recommendation connection edge"
type RecommendationEdge {
    node: Recommendation
}

"Notification for when new media is added to the site"
type RelatedMediaAdditionNotification {
    "The notification context text"
    context: String
    "The time the notification was created at"
    createdAt: Int
    "The id of the Notification"
    id: Int!
    "The associated media of the airing schedule"
    media: Media
    "The id of the new media"
    mediaId: Int!
    "The type of notification"
    type: NotificationType
}

type Report {
    cleared: Boolean
    "When the entry data was created"
    createdAt: Int
    id: Int!
    reason: String
    reported: User
    reporter: User
}

"A Review that features in an anime or manga"
type Review {
    "The main review body text"
    body(
        "Return the string in pre-parsed html instead of markdown"
        asHtml: Boolean
    ): String
    "The time of the thread creation"
    createdAt: Int!
    "The id of the review"
    id: Int!
    "The media the review is of"
    media: Media
    "The id of the review's media"
    mediaId: Int!
    "For which type of media the review is for"
    mediaType: MediaType
    "If the review is not yet publicly published and is only viewable by creator"
    private: Boolean
    "The total user rating of the review"
    rating: Int
    "The amount of user ratings of the review"
    ratingAmount: Int
    "The review score of the media"
    score: Int
    "The url for the review page on the AniList website"
    siteUrl: String
    "A short summary of the review"
    summary: String
    "The time of the thread last update"
    updatedAt: Int!
    "The creator of the review"
    user: User
    "The id of the review's creator"
    userId: Int!
    "The rating of the review by currently authenticated user"
    userRating: ReviewRating
}

type ReviewConnection {
    edges: [ReviewEdge]
    nodes: [Review]
    "The pagination information"
    pageInfo: PageInfo
}

"Review connection edge"
type ReviewEdge {
    node: Review
}

"Feed of mod edit activity"
type RevisionHistory {
    "The action taken on the objects"
    action: RevisionHistoryAction
    "A JSON object of the fields that changed"
    changes: Json
    "The character the mod feed entry references"
    character: Character
    "When the mod feed entry was created"
    createdAt: Int
    "The id of the media"
    id: Int!
    "The media the mod feed entry references"
    media: Media
    "The staff member the mod feed entry references"
    staff: Staff
    "The studio the mod feed entry references"
    studio: Studio
    "The user who made the edit to the object"
    user: User
}

"A user's list score distribution."
type ScoreDistribution {
    "The amount of list entries with this score"
    amount: Int
    score: Int
}

type SiteStatistics {
    anime(
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        sort: [SiteTrendSort]
    ): SiteTrendConnection
    characters(
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        sort: [SiteTrendSort]
    ): SiteTrendConnection
    manga(
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        sort: [SiteTrendSort]
    ): SiteTrendConnection
    reviews(
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        sort: [SiteTrendSort]
    ): SiteTrendConnection
    staff(
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        sort: [SiteTrendSort]
    ): SiteTrendConnection
    studios(
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        sort: [SiteTrendSort]
    ): SiteTrendConnection
    users(
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        sort: [SiteTrendSort]
    ): SiteTrendConnection
}

"Daily site statistics"
type SiteTrend {
    "The change from yesterday"
    change: Int!
    count: Int!
    "The day the data was recorded (timestamp)"
    date: Int!
}

type SiteTrendConnection {
    edges: [SiteTrendEdge]
    nodes: [SiteTrend]
    "The pagination information"
    pageInfo: PageInfo
}

"Site trend connection edge"
type SiteTrendEdge {
    node: SiteTrend
}

"Voice actors or production staff"
type Staff {
    "The person's age in years"
    age: Int
    "The persons blood type"
    bloodType: String
    "Media the actor voiced characters in. (Same data as characters with media as node instead of characters)"
    characterMedia(
        onList: Boolean,
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        sort: [MediaSort]
    ): MediaConnection
    "Characters voiced by the actor"
    characters(
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        sort: [CharacterSort]
    ): CharacterConnection
    dateOfBirth: FuzzyDate
    dateOfDeath: FuzzyDate
    "A general description of the staff member"
    description(
        "Return the string in pre-parsed html instead of markdown"
        asHtml: Boolean
    ): String
    "The amount of user's who have favourited the staff member"
    favourites: Int
    "The staff's gender. Usually Male, Female, or Non-binary but can be any string."
    gender: String
    "The persons birthplace or hometown"
    homeTown: String
    "The id of the staff member"
    id: Int!
    "The staff images"
    image: StaffImage
    "If the staff member is marked as favourite by the currently authenticated user"
    isFavourite: Boolean!
    "If the staff member is blocked from being added to favourites"
    isFavouriteBlocked: Boolean!
    "The primary language the staff member dub's in"
    language: StaffLanguage @deprecated(reason: "Replaced with languageV2")
    "The primary language of the staff member. Current values: Japanese, English, Korean, Italian, Spanish, Portuguese, French, German, Hebrew, Hungarian, Chinese, Arabic, Filipino, Catalan"
    languageV2: String
    "Notes for site moderators"
    modNotes: String
    "The names of the staff member"
    name: StaffName
    "The person's primary occupations"
    primaryOccupations: [String]
    "The url for the staff page on the AniList website"
    siteUrl: String
    "Staff member that the submission is referencing"
    staff: Staff
    "Media where the staff member has a production role"
    staffMedia(
        onList: Boolean,
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        sort: [MediaSort],
        type: MediaType
    ): MediaConnection
    "Inner details of submission status"
    submissionNotes: String
    "Status of the submission"
    submissionStatus: Int
    "Submitter for the submission"
    submitter: User
    updatedAt: Int @deprecated(reason: "No data available")
    "[startYear, endYear] (If the 2nd value is not present staff is still active)"
    yearsActive: [Int]
}

type StaffConnection {
    edges: [StaffEdge]
    nodes: [Staff]
    "The pagination information"
    pageInfo: PageInfo
}

"Staff connection edge"
type StaffEdge {
    "The order the staff should be displayed from the users favourites"
    favouriteOrder: Int
    "The id of the connection"
    id: Int
    node: Staff
    "The role of the staff member in the production of the media"
    role: String
}

type StaffImage {
    "The person's image of media at its largest size"
    large: String
    "The person's image of media at medium size"
    medium: String
}

"The names of the staff member"
type StaffName {
    "Other names the staff member might be referred to as (pen names)"
    alternative: [String]
    "The person's given name"
    first: String
    "The person's first and last name"
    full: String
    "The person's surname"
    last: String
    "The person's middle name"
    middle: String
    "The person's full name in their native language"
    native: String
    "The currently authenticated users preferred name language. Default romaji for non-authenticated"
    userPreferred: String
}

"Voice actor role for a character"
type StaffRoleType {
    "Used for grouping roles where multiple dubs exist for the same language. Either dubbing company name or language variant."
    dubGroup: String
    "Notes regarding the VA's role for the character"
    roleNotes: String
    "The voice actors of the character"
    voiceActor: Staff
}

"User's staff statistics"
type StaffStats {
    amount: Int
    meanScore: Int
    staff: Staff
    "The amount of time in minutes the staff member has been watched by the user"
    timeWatched: Int
}

"A submission for a staff that features in an anime or manga"
type StaffSubmission {
    "Data Mod assigned to handle the submission"
    assignee: User
    createdAt: Int
    "The id of the submission"
    id: Int!
    "Whether the submission is locked"
    locked: Boolean
    "Inner details of submission status"
    notes: String
    source: String
    "Staff that the submission is referencing"
    staff: Staff
    "Status of the submission"
    status: SubmissionStatus
    "The staff submission changes"
    submission: Staff
    "Submitter for the submission"
    submitter: User
}

"The distribution of the watching/reading status of media or a user's list"
type StatusDistribution {
    "The amount of entries with this status"
    amount: Int
    "The day the activity took place (Unix timestamp)"
    status: MediaListStatus
}

"Animation or production company"
type Studio {
    "The amount of user's who have favourited the studio"
    favourites: Int
    "The id of the studio"
    id: Int!
    "If the studio is an animation studio or a different kind of company"
    isAnimationStudio: Boolean!
    "If the studio is marked as favourite by the currently authenticated user"
    isFavourite: Boolean!
    "The media the studio has worked on"
    media(
        "If the studio was the primary animation studio of the media"
        isMain: Boolean,
        onList: Boolean,
        "The page"
        page: Int,
        "The amount of entries per page, max 25"
        perPage: Int,
        "The order the results will be returned in"
        sort: [MediaSort]
    ): MediaConnection
    "The name of the studio"
    name: String!
    "The url for the studio page on the AniList website"
    siteUrl: String
}

type StudioConnection {
    edges: [StudioEdge]
    nodes: [Studio]
    "The pagination information"
    pageInfo: PageInfo
}

"Studio connection edge"
type StudioEdge {
    "The order the character should be displayed from the users favourites"
    favouriteOrder: Int
    "The id of the connection"
    id: Int
    "If the studio is the main animation studio of the anime"
    isMain: Boolean!
    node: Studio
}

"User's studio statistics"
type StudioStats {
    amount: Int
    meanScore: Int
    studio: Studio
    "The amount of time in minutes the studio's works have been watched by the user"
    timeWatched: Int
}

"User's tag statistics"
type TagStats {
    amount: Int
    meanScore: Int
    tag: MediaTag
    "The amount of time in minutes the tag has been watched by the user"
    timeWatched: Int
}

"User text activity"
type TextActivity {
    "The time the activity was created at"
    createdAt: Int!
    "The id of the activity"
    id: Int!
    "If the currently authenticated user liked the activity"
    isLiked: Boolean
    "If the activity is locked and can receive replies"
    isLocked: Boolean
    "If the currently authenticated user is subscribed to the activity"
    isSubscribed: Boolean
    "The amount of likes the activity has"
    likeCount: Int!
    "The users who liked the activity"
    likes: [User]
    "The written replies to the activity"
    replies: [ActivityReply]
    "The number of activity replies"
    replyCount: Int!
    "The url for the activity page on the AniList website"
    siteUrl: String
    "The status text (Markdown)"
    text(
        "Return the string in pre-parsed html instead of markdown"
        asHtml: Boolean
    ): String
    "The type of activity"
    type: ActivityType
    "The user who created the activity"
    user: User
    "The user id of the activity's creator"
    userId: Int
}

"Forum Thread"
type Thread {
    "The text body of the thread (Markdown)"
    body(
        "Return the string in pre-parsed html instead of markdown"
        asHtml: Boolean
    ): String
    "The categories of the thread"
    categories: [ThreadCategory]
    "The time of the thread creation"
    createdAt: Int!
    "The id of the thread"
    id: Int!
    "If the currently authenticated user liked the thread"
    isLiked: Boolean
    "If the thread is locked and can receive comments"
    isLocked: Boolean
    "If the thread is stickied and should be displayed at the top of the page"
    isSticky: Boolean
    "If the currently authenticated user is subscribed to the thread"
    isSubscribed: Boolean
    "The amount of likes the thread has"
    likeCount: Int!
    "The users who liked the thread"
    likes: [User]
    "The media categories of the thread"
    mediaCategories: [Media]
    "The time of the last reply"
    repliedAt: Int
    "The id of the most recent comment on the thread"
    replyCommentId: Int
    "The number of comments on the thread"
    replyCount: Int
    "The user to last reply to the thread"
    replyUser: User
    "The id of the user who most recently commented on the thread"
    replyUserId: Int
    "The url for the thread page on the AniList website"
    siteUrl: String
    "The title of the thread"
    title: String
    "The time of the thread last update"
    updatedAt: Int!
    "The owner of the thread"
    user: User
    "The id of the thread owner user"
    userId: Int!
    "The number of times users have viewed the thread"
    viewCount: Int
}

"A forum thread category"
type ThreadCategory {
    "The id of the category"
    id: Int!
    "The name of the category"
    name: String!
}

"Forum Thread Comment"
type ThreadComment {
    "The comment's child reply comments"
    childComments: Json
    "The text content of the comment (Markdown)"
    comment(
        "Return the string in pre-parsed html instead of markdown"
        asHtml: Boolean
    ): String
    "The time of the comments creation"
    createdAt: Int!
    "The id of the comment"
    id: Int!
    "If the currently authenticated user liked the comment"
    isLiked: Boolean
    "If the comment tree is locked and may not receive replies or edits"
    isLocked: Boolean
    "The amount of likes the comment has"
    likeCount: Int!
    "The users who liked the comment"
    likes: [User]
    "The url for the comment page on the AniList website"
    siteUrl: String
    "The thread the comment belongs to"
    thread: Thread
    "The id of thread the comment belongs to"
    threadId: Int
    "The time of the comments last update"
    updatedAt: Int!
    "The user who created the comment"
    user: User
    "The user id of the comment's owner"
    userId: Int
}

"Notification for when a thread comment is liked"
type ThreadCommentLikeNotification {
    "The thread comment that was liked"
    comment: ThreadComment
    "The id of the activity which was liked"
    commentId: Int!
    "The notification context text"
    context: String
    "The time the notification was created at"
    createdAt: Int
    "The id of the Notification"
    id: Int!
    "The thread that the relevant comment belongs to"
    thread: Thread
    "The type of notification"
    type: NotificationType
    "The user who liked the activity"
    user: User
    "The id of the user who liked to the activity"
    userId: Int!
}

"Notification for when authenticated user is @ mentioned in a forum thread comment"
type ThreadCommentMentionNotification {
    "The thread comment that included the @ mention"
    comment: ThreadComment
    "The id of the comment where mentioned"
    commentId: Int!
    "The notification context text"
    context: String
    "The time the notification was created at"
    createdAt: Int
    "The id of the Notification"
    id: Int!
    "The thread that the relevant comment belongs to"
    thread: Thread
    "The type of notification"
    type: NotificationType
    "The user who mentioned the authenticated user"
    user: User
    "The id of the user who mentioned the authenticated user"
    userId: Int!
}

"Notification for when a user replies to your forum thread comment"
type ThreadCommentReplyNotification {
    "The reply thread comment"
    comment: ThreadComment
    "The id of the reply comment"
    commentId: Int!
    "The notification context text"
    context: String
    "The time the notification was created at"
    createdAt: Int
    "The id of the Notification"
    id: Int!
    "The thread that the relevant comment belongs to"
    thread: Thread
    "The type of notification"
    type: NotificationType
    "The user who replied to the activity"
    user: User
    "The id of the user who create the comment reply"
    userId: Int!
}

"Notification for when a user replies to a subscribed forum thread"
type ThreadCommentSubscribedNotification {
    "The reply thread comment"
    comment: ThreadComment
    "The id of the new comment in the subscribed thread"
    commentId: Int!
    "The notification context text"
    context: String
    "The time the notification was created at"
    createdAt: Int
    "The id of the Notification"
    id: Int!
    "The thread that the relevant comment belongs to"
    thread: Thread
    "The type of notification"
    type: NotificationType
    "The user who replied to the subscribed thread"
    user: User
    "The id of the user who commented on the thread"
    userId: Int!
}

"Notification for when a thread is liked"
type ThreadLikeNotification {
    "The liked thread comment"
    comment: ThreadComment
    "The notification context text"
    context: String
    "The time the notification was created at"
    createdAt: Int
    "The id of the Notification"
    id: Int!
    "The thread that the relevant comment belongs to"
    thread: Thread
    "The id of the thread which was liked"
    threadId: Int!
    "The type of notification"
    type: NotificationType
    "The user who liked the activity"
    user: User
    "The id of the user who liked to the activity"
    userId: Int!
}

"A user"
type User {
    "The bio written by user (Markdown)"
    about(
        "Return the string in pre-parsed html instead of markdown"
        asHtml: Boolean
    ): String
    "The user's avatar images"
    avatar: UserAvatar
    "The user's banner images"
    bannerImage: String
    bans: Json
    "When the user's account was created. (Does not exist for accounts created before 2020)"
    createdAt: Int
    "Custom donation badge text"
    donatorBadge: String
    "The donation tier of the user"
    donatorTier: Int
    "The users favourites"
    favourites(
        "Deprecated. Use page arguments on each favourite field instead."
        page: Int
    ): Favourites
    "The id of the user"
    id: Int!
    "If the user is blocked by the authenticated user"
    isBlocked: Boolean
    "If this user if following the authenticated user"
    isFollower: Boolean
    "If the authenticated user if following this user"
    isFollowing: Boolean
    "The user's media list options"
    mediaListOptions: MediaListOptions
    "The user's moderator roles if they are a site moderator"
    moderatorRoles: [ModRole]
    "If the user is a moderator or data moderator"
    moderatorStatus: String @deprecated(reason: "Deprecated. Replaced with moderatorRoles field.")
    "The name of the user"
    name: String!
    "The user's general options"
    options: UserOptions
    "The user's previously used names."
    previousNames: [UserPreviousName]
    "The url for the user page on the AniList website"
    siteUrl: String
    "The users anime & manga list statistics"
    statistics: UserStatisticTypes
    "The user's statistics"
    stats: UserStats @deprecated(reason: "Deprecated. Replaced with statistics field.")
    "The number of unread notifications the user has"
    unreadNotificationCount: Int
    "When the user's data was last updated"
    updatedAt: Int
}

"A user's activity history stats."
type UserActivityHistory {
    "The amount of activity on the day"
    amount: Int
    "The day the activity took place (Unix timestamp)"
    date: Int
    "The level of activity represented on a 1-10 scale"
    level: Int
}

"A user's avatars"
type UserAvatar {
    "The avatar of user at its largest size"
    large: String
    "The avatar of user at medium size"
    medium: String
}

type UserCountryStatistic {
    chaptersRead: Int!
    count: Int!
    country: CountryCode
    meanScore: Float!
    mediaIds: [Int]!
    minutesWatched: Int!
}

type UserFormatStatistic {
    chaptersRead: Int!
    count: Int!
    format: MediaFormat
    meanScore: Float!
    mediaIds: [Int]!
    minutesWatched: Int!
}

type UserGenreStatistic {
    chaptersRead: Int!
    count: Int!
    genre: String
    meanScore: Float!
    mediaIds: [Int]!
    minutesWatched: Int!
}

type UserLengthStatistic {
    chaptersRead: Int!
    count: Int!
    length: String
    meanScore: Float!
    mediaIds: [Int]!
    minutesWatched: Int!
}

"User data for moderators"
type UserModData {
    alts: [User]
    bans: Json
    counts: Json
    email: String
    ip: Json
    privacy: Int
}

"A user's general options"
type UserOptions {
    "Minutes between activity for them to be merged together. 0 is Never, Above 2 weeks (20160 mins) is Always."
    activityMergeTime: Int
    "Whether the user receives notifications when a show they are watching aires"
    airingNotifications: Boolean
    "Whether the user has enabled viewing of 18+ content"
    displayAdultContent: Boolean
    "Notification options"
    notificationOptions: [NotificationOption]
    "Profile highlight color (blue, purple, pink, orange, red, green, gray)"
    profileColor: String
    "The language the user wants to see staff and character names in"
    staffNameLanguage: UserStaffNameLanguage
    "The user's timezone offset (Auth user only)"
    timezone: String
    "The language the user wants to see media titles in"
    titleLanguage: UserTitleLanguage
}

"A user's previous name"
type UserPreviousName {
    "When the user first changed from this name."
    createdAt: Int
    "A previous name of the user."
    name: String
    "When the user most recently changed from this name."
    updatedAt: Int
}

type UserReleaseYearStatistic {
    chaptersRead: Int!
    count: Int!
    meanScore: Float!
    mediaIds: [Int]!
    minutesWatched: Int!
    releaseYear: Int
}

type UserScoreStatistic {
    chaptersRead: Int!
    count: Int!
    meanScore: Float!
    mediaIds: [Int]!
    minutesWatched: Int!
    score: Int
}

type UserStaffStatistic {
    chaptersRead: Int!
    count: Int!
    meanScore: Float!
    mediaIds: [Int]!
    minutesWatched: Int!
    staff: Staff
}

type UserStartYearStatistic {
    chaptersRead: Int!
    count: Int!
    meanScore: Float!
    mediaIds: [Int]!
    minutesWatched: Int!
    startYear: Int
}

type UserStatisticTypes {
    anime: UserStatistics
    manga: UserStatistics
}

type UserStatistics {
    chaptersRead: Int!
    count: Int!
    countries(limit: Int, sort: [UserStatisticsSort]): [UserCountryStatistic]
    episodesWatched: Int!
    formats(limit: Int, sort: [UserStatisticsSort]): [UserFormatStatistic]
    genres(limit: Int, sort: [UserStatisticsSort]): [UserGenreStatistic]
    lengths(limit: Int, sort: [UserStatisticsSort]): [UserLengthStatistic]
    meanScore: Float!
    minutesWatched: Int!
    releaseYears(limit: Int, sort: [UserStatisticsSort]): [UserReleaseYearStatistic]
    scores(limit: Int, sort: [UserStatisticsSort]): [UserScoreStatistic]
    staff(limit: Int, sort: [UserStatisticsSort]): [UserStaffStatistic]
    standardDeviation: Float!
    startYears(limit: Int, sort: [UserStatisticsSort]): [UserStartYearStatistic]
    statuses(limit: Int, sort: [UserStatisticsSort]): [UserStatusStatistic]
    studios(limit: Int, sort: [UserStatisticsSort]): [UserStudioStatistic]
    tags(limit: Int, sort: [UserStatisticsSort]): [UserTagStatistic]
    voiceActors(limit: Int, sort: [UserStatisticsSort]): [UserVoiceActorStatistic]
    volumesRead: Int!
}

"A user's statistics"
type UserStats {
    activityHistory: [UserActivityHistory]
    animeListScores: ListScoreStats
    animeScoreDistribution: [ScoreDistribution]
    animeStatusDistribution: [StatusDistribution]
    "The amount of manga chapters the user has read"
    chaptersRead: Int
    favouredActors: [StaffStats]
    favouredFormats: [FormatStats]
    favouredGenres: [GenreStats]
    favouredGenresOverview: [GenreStats]
    favouredStaff: [StaffStats]
    favouredStudios: [StudioStats]
    favouredTags: [TagStats]
    favouredYears: [YearStats]
    mangaListScores: ListScoreStats
    mangaScoreDistribution: [ScoreDistribution]
    mangaStatusDistribution: [StatusDistribution]
    "The amount of anime the user has watched in minutes"
    watchedTime: Int
}

type UserStatusStatistic {
    chaptersRead: Int!
    count: Int!
    meanScore: Float!
    mediaIds: [Int]!
    minutesWatched: Int!
    status: MediaListStatus
}

type UserStudioStatistic {
    chaptersRead: Int!
    count: Int!
    meanScore: Float!
    mediaIds: [Int]!
    minutesWatched: Int!
    studio: Studio
}

type UserTagStatistic {
    chaptersRead: Int!
    count: Int!
    meanScore: Float!
    mediaIds: [Int]!
    minutesWatched: Int!
    tag: MediaTag
}

type UserVoiceActorStatistic {
    chaptersRead: Int!
    characterIds: [Int]!
    count: Int!
    meanScore: Float!
    mediaIds: [Int]!
    minutesWatched: Int!
    voiceActor: Staff
}

"User's year statistics"
type YearStats {
    amount: Int
    meanScore: Int
    year: Int
}

"Activity sort enums"
enum ActivitySort {
    ID
    ID_DESC
}

"Activity type enum."
enum ActivityType {
    "A anime list update activity"
    ANIME_LIST
    "A manga list update activity"
    MANGA_LIST
    "Anime & Manga list update, only used in query arguments"
    MEDIA_LIST
    "A text message activity sent to another user"
    MESSAGE
    "A text activity"
    TEXT
}

"Airing schedule sort enums"
enum AiringSort {
    EPISODE
    EPISODE_DESC
    ID
    ID_DESC
    MEDIA_ID
    MEDIA_ID_DESC
    TIME
    TIME_DESC
}

"The role the character plays in the media"
enum CharacterRole {
    "A background character in the media"
    BACKGROUND
    "A primary character role in the media"
    MAIN
    "A supporting character role in the media"
    SUPPORTING
}

"Character sort enums"
enum CharacterSort {
    FAVOURITES
    FAVOURITES_DESC
    ID
    ID_DESC
    "Order manually decided by moderators"
    RELEVANCE
    ROLE
    ROLE_DESC
    SEARCH_MATCH
}

"Types that can be liked"
enum LikeableType {
    ACTIVITY
    ACTIVITY_REPLY
    THREAD
    THREAD_COMMENT
}

"The format the media was released in"
enum MediaFormat {
    "Professionally published manga with more than one chapter"
    MANGA
    "Anime movies with a theatrical release"
    MOVIE
    "Short anime released as a music video"
    MUSIC
    "Written books released as a series of light novels"
    NOVEL
    "(Original Net Animation) Anime that have been originally released online or are only available through streaming services."
    ONA
    "Manga with just one chapter"
    ONE_SHOT
    "(Original Video Animation) Anime that have been released directly on DVD/Blu-ray without originally going through a theatrical release or television broadcast"
    OVA
    "Special episodes that have been included in DVD/Blu-ray releases, picture dramas, pilots, etc"
    SPECIAL
    "Anime broadcast on television"
    TV
    "Anime which are under 15 minutes in length and broadcast on television"
    TV_SHORT
}

"Media list sort enums"
enum MediaListSort {
    ADDED_TIME
    ADDED_TIME_DESC
    FINISHED_ON
    FINISHED_ON_DESC
    MEDIA_ID
    MEDIA_ID_DESC
    MEDIA_POPULARITY
    MEDIA_POPULARITY_DESC
    MEDIA_TITLE_ENGLISH
    MEDIA_TITLE_ENGLISH_DESC
    MEDIA_TITLE_NATIVE
    MEDIA_TITLE_NATIVE_DESC
    MEDIA_TITLE_ROMAJI
    MEDIA_TITLE_ROMAJI_DESC
    PRIORITY
    PRIORITY_DESC
    PROGRESS
    PROGRESS_DESC
    PROGRESS_VOLUMES
    PROGRESS_VOLUMES_DESC
    REPEAT
    REPEAT_DESC
    SCORE
    SCORE_DESC
    STARTED_ON
    STARTED_ON_DESC
    STATUS
    STATUS_DESC
    UPDATED_TIME
    UPDATED_TIME_DESC
}

"Media list watching/reading status enum."
enum MediaListStatus {
    "Finished watching/reading"
    COMPLETED
    "Currently watching/reading"
    CURRENT
    "Stopped watching/reading before completing"
    DROPPED
    "Paused watching/reading"
    PAUSED
    "Planning to watch/read"
    PLANNING
    "Re-watching/reading"
    REPEATING
}

"The type of ranking"
enum MediaRankType {
    "Ranking is based on the media's popularity"
    POPULAR
    "Ranking is based on the media's ratings/score"
    RATED
}

"Type of relation media has to its parent."
enum MediaRelation {
    "An adaption of this media into a different format"
    ADAPTATION
    "An alternative version of the same media"
    ALTERNATIVE
    "Shares at least 1 character"
    CHARACTER
    "Version 2 only."
    COMPILATION
    "Version 2 only."
    CONTAINS
    "Other"
    OTHER
    "The media a side story is from"
    PARENT
    "Released before the relation"
    PREQUEL
    "Released after the relation"
    SEQUEL
    "A side story of the parent media"
    SIDE_STORY
    "Version 2 only. The source material the media was adapted from"
    SOURCE
    "An alternative version of the media with a different primary focus"
    SPIN_OFF
    "A shortened and summarized version"
    SUMMARY
}

enum MediaSeason {
    "Months September to November"
    FALL
    "Months March to May"
    SPRING
    "Months June to August"
    SUMMER
    "Months December to February"
    WINTER
}

"Media sort enums"
enum MediaSort {
    CHAPTERS
    CHAPTERS_DESC
    DURATION
    DURATION_DESC
    END_DATE
    END_DATE_DESC
    EPISODES
    EPISODES_DESC
    FAVOURITES
    FAVOURITES_DESC
    FORMAT
    FORMAT_DESC
    ID
    ID_DESC
    POPULARITY
    POPULARITY_DESC
    SCORE
    SCORE_DESC
    SEARCH_MATCH
    START_DATE
    START_DATE_DESC
    STATUS
    STATUS_DESC
    TITLE_ENGLISH
    TITLE_ENGLISH_DESC
    TITLE_NATIVE
    TITLE_NATIVE_DESC
    TITLE_ROMAJI
    TITLE_ROMAJI_DESC
    TRENDING
    TRENDING_DESC
    TYPE
    TYPE_DESC
    UPDATED_AT
    UPDATED_AT_DESC
    VOLUMES
    VOLUMES_DESC
}

"Source type the media was adapted from"
enum MediaSource {
    "Version 2+ only. Japanese Anime"
    ANIME
    "Version 3 only. Comics excluding manga"
    COMIC
    "Version 2+ only. Self-published works"
    DOUJINSHI
    "Version 3 only. Games excluding video games"
    GAME
    "Written work published in volumes"
    LIGHT_NOVEL
    "Version 3 only. Live action media such as movies or TV show"
    LIVE_ACTION
    "Asian comic book"
    MANGA
    "Version 3 only. Multimedia project"
    MULTIMEDIA_PROJECT
    "Version 2+ only. Written works not published in volumes"
    NOVEL
    "An original production not based of another work"
    ORIGINAL
    "Other"
    OTHER
    "Version 3 only. Picture book"
    PICTURE_BOOK
    "Video game"
    VIDEO_GAME
    "Video game driven primary by text and narrative"
    VISUAL_NOVEL
    "Version 3 only. Written works published online"
    WEB_NOVEL
}

"The current releasing status of the media"
enum MediaStatus {
    "Ended before the work could be finished"
    CANCELLED
    "Has completed and is no longer being released"
    FINISHED
    "Version 2 only. Is currently paused from releasing and will resume at a later date"
    HIATUS
    "To be released at a later date"
    NOT_YET_RELEASED
    "Currently releasing"
    RELEASING
}

"Media trend sort enums"
enum MediaTrendSort {
    DATE
    DATE_DESC
    EPISODE
    EPISODE_DESC
    ID
    ID_DESC
    MEDIA_ID
    MEDIA_ID_DESC
    POPULARITY
    POPULARITY_DESC
    SCORE
    SCORE_DESC
    TRENDING
    TRENDING_DESC
}

"Media type enum, anime or manga."
enum MediaType {
    "Japanese Anime"
    ANIME
    "Asian comic"
    MANGA
}

enum ModActionType {
    ANON
    BAN
    DELETE
    EDIT
    EXPIRE
    NOTE
    REPORT
    RESET
}

"Mod role enums"
enum ModRole {
    "An AniList administrator"
    ADMIN
    "An anime data moderator"
    ANIME_DATA
    "A community moderator"
    COMMUNITY
    "An AniList developer"
    DEVELOPER
    "A discord community moderator"
    DISCORD_COMMUNITY
    "A lead anime data moderator"
    LEAD_ANIME_DATA
    "A lead community moderator"
    LEAD_COMMUNITY
    "A head developer of AniList"
    LEAD_DEVELOPER
    "A lead manga data moderator"
    LEAD_MANGA_DATA
    "A lead social media moderator"
    LEAD_SOCIAL_MEDIA
    "A manga data moderator"
    MANGA_DATA
    "A retired moderator"
    RETIRED
    "A social media moderator"
    SOCIAL_MEDIA
}

"Notification type enum"
enum NotificationType {
    "A user has liked your activity"
    ACTIVITY_LIKE
    "A user has mentioned you in their activity"
    ACTIVITY_MENTION
    "A user has sent you message"
    ACTIVITY_MESSAGE
    "A user has replied to your activity"
    ACTIVITY_REPLY
    "A user has liked your activity reply"
    ACTIVITY_REPLY_LIKE
    "A user has replied to activity you have also replied to"
    ACTIVITY_REPLY_SUBSCRIBED
    "An anime you are currently watching has aired"
    AIRING
    "A user has followed you"
    FOLLOWING
    "An anime or manga has had a data change that affects how a user may track it in their lists"
    MEDIA_DATA_CHANGE
    "An anime or manga on the user's list has been deleted from the site"
    MEDIA_DELETION
    "Anime or manga entries on the user's list have been merged into a single entry"
    MEDIA_MERGE
    "A new anime or manga has been added to the site where its related media is on the user's list"
    RELATED_MEDIA_ADDITION
    "A user has liked your forum comment"
    THREAD_COMMENT_LIKE
    "A user has mentioned you in a forum comment"
    THREAD_COMMENT_MENTION
    "A user has replied to your forum comment"
    THREAD_COMMENT_REPLY
    "A user has liked your forum thread"
    THREAD_LIKE
    "A user has commented in one of your subscribed forum threads"
    THREAD_SUBSCRIBED
}

"Recommendation rating enums"
enum RecommendationRating {
    NO_RATING
    RATE_DOWN
    RATE_UP
}

"Recommendation sort enums"
enum RecommendationSort {
    ID
    ID_DESC
    RATING
    RATING_DESC
}

"Review rating enums"
enum ReviewRating {
    DOWN_VOTE
    NO_VOTE
    UP_VOTE
}

"Review sort enums"
enum ReviewSort {
    CREATED_AT
    CREATED_AT_DESC
    ID
    ID_DESC
    RATING
    RATING_DESC
    SCORE
    SCORE_DESC
    UPDATED_AT
    UPDATED_AT_DESC
}

"Revision history actions"
enum RevisionHistoryAction {
    CREATE
    EDIT
}

"Media list scoring type"
enum ScoreFormat {
    "An integer from 0-10"
    POINT_10
    "An integer from 0-100"
    POINT_100
    "A float from 0-10 with 1 decimal place"
    POINT_10_DECIMAL
    "An integer from 0-3. Should be represented in Smileys. 0 => No Score, 1 => :(, 2 => :|, 3 => :)"
    POINT_3
    "An integer from 0-5. Should be represented in Stars"
    POINT_5
}

"Site trend sort enums"
enum SiteTrendSort {
    CHANGE
    CHANGE_DESC
    COUNT
    COUNT_DESC
    DATE
    DATE_DESC
}

"The primary language of the voice actor"
enum StaffLanguage {
    "English"
    ENGLISH
    "French"
    FRENCH
    "German"
    GERMAN
    "Hebrew"
    HEBREW
    "Hungarian"
    HUNGARIAN
    "Italian"
    ITALIAN
    "Japanese"
    JAPANESE
    "Korean"
    KOREAN
    "Portuguese"
    PORTUGUESE
    "Spanish"
    SPANISH
}

"Staff sort enums"
enum StaffSort {
    FAVOURITES
    FAVOURITES_DESC
    ID
    ID_DESC
    LANGUAGE
    LANGUAGE_DESC
    "Order manually decided by moderators"
    RELEVANCE
    ROLE
    ROLE_DESC
    SEARCH_MATCH
}

"Studio sort enums"
enum StudioSort {
    FAVOURITES
    FAVOURITES_DESC
    ID
    ID_DESC
    NAME
    NAME_DESC
    SEARCH_MATCH
}

"Submission sort enums"
enum SubmissionSort {
    ID
    ID_DESC
}

"Submission status"
enum SubmissionStatus {
    ACCEPTED
    PARTIALLY_ACCEPTED
    PENDING
    REJECTED
}

"Thread comments sort enums"
enum ThreadCommentSort {
    ID
    ID_DESC
}

"Thread sort enums"
enum ThreadSort {
    CREATED_AT
    CREATED_AT_DESC
    ID
    ID_DESC
    IS_STICKY
    REPLIED_AT
    REPLIED_AT_DESC
    REPLY_COUNT
    REPLY_COUNT_DESC
    SEARCH_MATCH
    TITLE
    TITLE_DESC
    UPDATED_AT
    UPDATED_AT_DESC
    VIEW_COUNT
    VIEW_COUNT_DESC
}

"User sort enums"
enum UserSort {
    CHAPTERS_READ
    CHAPTERS_READ_DESC
    ID
    ID_DESC
    SEARCH_MATCH
    USERNAME
    USERNAME_DESC
    WATCHED_TIME
    WATCHED_TIME_DESC
}

"The language the user wants to see staff and character names in"
enum UserStaffNameLanguage {
    "The staff or character's name in their native language"
    NATIVE
    "The romanization of the staff or character's native name"
    ROMAJI
    "The romanization of the staff or character's native name, with western name ordering"
    ROMAJI_WESTERN
}

"User statistics sort enum"
enum UserStatisticsSort {
    COUNT
    COUNT_DESC
    ID
    ID_DESC
    MEAN_SCORE
    MEAN_SCORE_DESC
    PROGRESS
    PROGRESS_DESC
}

"The language the user wants to see media titles in"
enum UserTitleLanguage {
    "The official english title"
    ENGLISH
    "The official english title, stylised by media creator"
    ENGLISH_STYLISED
    "Official title in it's native language"
    NATIVE
    "Official title in it's native language, stylised by media creator"
    NATIVE_STYLISED
    "The romanization of the native language title"
    ROMAJI
    "The romanization of the native language title, stylised by media creator"
    ROMAJI_STYLISED
}

"ISO 3166-1 alpha-2 country code"
scalar CountryCode

"8 digit long date integer (YYYYMMDD). Unknown dates represented by 0. E.g. 2016: 20160000, May 1976: 19760500"
scalar FuzzyDateInt

scalar Json

input AiringScheduleInput {
    airingAt: Int
    episode: Int
    timeUntilAiring: Int
}

input AniChartHighlightInput {
    highlight: String
    mediaId: Int
}

"The names of the character"
input CharacterNameInput {
    "Other names the character might be referred by"
    alternative: [String]
    "Other names the character might be referred to as but are spoilers"
    alternativeSpoiler: [String]
    "The character's given name"
    first: String
    "The character's surname"
    last: String
    "The character's middle name"
    middle: String
    "The character's full name in their native language"
    native: String
}

"Date object that allows for incomplete date values (fuzzy)"
input FuzzyDateInput {
    "Numeric Day (24)"
    day: Int
    "Numeric Month (3)"
    month: Int
    "Numeric Year (2017)"
    year: Int
}

"An external link to another site related to the media"
input MediaExternalLinkInput {
    "The id of the external link"
    id: Int!
    "The site location of the external link"
    site: String!
    "The url of the external link"
    url: String!
}

"A user's list options for anime or manga lists"
input MediaListOptionsInput {
    "The names of the user's advanced scoring sections"
    advancedScoring: [String]
    "If advanced scoring is enabled"
    advancedScoringEnabled: Boolean
    "The names of the user's custom lists"
    customLists: [String]
    "The order each list should be displayed in"
    sectionOrder: [String]
    "If the completed sections of the list should be separated by format"
    splitCompletedSectionByFormat: Boolean
    "list theme"
    theme: String
}

"The official titles of the media in various languages"
input MediaTitleInput {
    "The official english title"
    english: String
    "Official title in it's native language"
    native: String
    "The romanization of the native language title"
    romaji: String
}

"Notification option input"
input NotificationOptionInput {
    "Whether this type of notification is enabled"
    enabled: Boolean
    "The type of notification"
    type: NotificationType
}

"The names of the staff member"
input StaffNameInput {
    "Other names the character might be referred by"
    alternative: [String]
    "The person's given name"
    first: String
    "The person's surname"
    last: String
    "The person's middle name"
    middle: String
    "The person's full name in their native language"
    native: String
}
